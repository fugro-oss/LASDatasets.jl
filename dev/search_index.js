var documenterSearchIndex = {"docs":
[{"location":"header/#Header","page":"Header","title":"Header","text":"","category":"section"},{"location":"header/","page":"Header","title":"Header","text":"Each LAS file starts with a block of header information that contains metadata for the whole file. LASDatasets.jl uses the LasHeader struct to wrap around this data and defines a user-friendly interface to modify certain aspects of it.","category":"page"},{"location":"header/","page":"Header","title":"Header","text":"LasHeader","category":"page"},{"location":"header/#LASDatasets.LasHeader-header","page":"Header","title":"LASDatasets.LasHeader","text":"mutable struct LasHeader\n\nA LAS Header containing metadata regarding information in a LAS file See full specification here\n\nlas_version::VersionNumber: The LAS spec version this header was written in\nfile_source_id::UInt16: Numeric identifier for the source that made this file. Set to 0 if the ID is unassigned\nglobal_encoding::UInt16: A bit field used to indicate global properties. See the spec for more info\nguid_1::UInt32: First member of the Project GUID\nguid_2::UInt16: Second member of the Project GUID\nguid_3::UInt16: Third member of the Project GUID\nguid_4::NTuple{8, UInt8}: Fourth member of the Project GUID\nsystem_id::NTuple{32, UInt8}: A unique identifier indicating how the data was created\nsoftware_id::NTuple{32, UInt8}: Identifier for the software that created the LAS file\ncreation_dayofyear::UInt16: The Greenwich Mean Time (GMT) day of the year (as an unsigned short) on which the file was created\ncreation_year::UInt16: Four digit number for the year the file was created\nheader_size::UInt16: Size (in bytes) of the public header block in the LAS file. This varies depending on which LAS version was used to write it. For LAS v1.4 it's 375 bytes\ndata_offset::UInt32: Offset to the point data (in bytes) from the start of the file to the first field of the first point record\nn_vlr::UInt32: Number of Variable Length Records (VLR's) in the LAS file. These come after the header and before the point records\ndata_format_id::UInt8: Point data record format stored in the LAS file. LAS v1.4 supports formats 0-10\ndata_record_length::UInt16: Size in bytes of a point data record\nlegacy_record_count::UInt32: For maintaining legacy compatibility, the number of point records in the file (must not exceed typemax(UInt32)). Only populated for point records 0-5\nlegacy_point_return_count::NTuple{5, UInt32}: For maintaining legacy compatibility, the number of points per return (max of 5 returns, counts must not exceed typemax(UInt32)). Only populated for point records 0-5\nspatial_info::SpatialInfo: Spatial information describing the bounding range of the points, their offsets and any scaling factor applied to them\nwaveform_record_start::UInt64: Offset in bytes from the start of the file to the first byte of the Waveform Data Package Reckord\nevlr_start::UInt64: Offset in bytes from the start of the file to the first byte of the first Extended Variable Length Record (EVLR)\nn_evlr::UInt32: Number of EVLR's in the LAS file\nrecord_count::UInt64: Number of point records saved in this file (can't exceed typemax(UInt64)). This is populated for LAS v1.4\npoint_return_count::NTuple{15, UInt64}: Number of points per return saved in this file (15 returns total, counts can't exceed typemax(UInt64)). This is populated for LAS v1.4\n\n\n\n\n\n","category":"type"},{"location":"header/","page":"Header","title":"Header","text":"You can access information from the header using any of the following functions:","category":"page"},{"location":"header/","page":"Header","title":"Header","text":"las_version\nfile_source_id\nglobal_encoding\nsystem_id\nsoftware_id\ncreation_day_of_year\ncreation_year\nheader_size\npoint_data_offset\npoint_record_length\npoint_format\nnumber_of_points\nget_number_of_points_by_return\nnumber_of_vlrs\nnumber_of_evlrs\nevlr_start\nspatial_info\nnum_return_channels\nis_standard_gps\nis_wkt\nis_internal_waveform\nis_external_waveform\nwaveform_record_start","category":"page"},{"location":"header/#LASDatasets.las_version-header","page":"Header","title":"LASDatasets.las_version","text":"las_version(h::LasHeader) -> VersionNumber\n\n\nGet the LAS specification version from a header h\n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.file_source_id-header","page":"Header","title":"LASDatasets.file_source_id","text":"file_source_id(h::LasHeader) -> UInt16\n\n\nGet the file source ID specification version from a header h\n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.global_encoding-header","page":"Header","title":"LASDatasets.global_encoding","text":"global_encoding(h::LasHeader) -> UInt16\n\n\nGet the global properties bit vector from a header h\n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.system_id-header","page":"Header","title":"LASDatasets.system_id","text":"system_id(h::LasHeader) -> String\n\n\nGet the system ID from a header h\n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.software_id-header","page":"Header","title":"LASDatasets.software_id","text":"software_id(h::LasHeader) -> String\n\n\nGet the software ID from a header h\n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.creation_day_of_year-header","page":"Header","title":"LASDatasets.creation_day_of_year","text":"creation_day_of_year(h::LasHeader) -> UInt16\n\n\nGet the creation day of the year from a header h\n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.creation_year-header","page":"Header","title":"LASDatasets.creation_year","text":"creation_year(h::LasHeader) -> UInt16\n\n\nGet the creation year from a header h\n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.header_size-header","page":"Header","title":"LASDatasets.header_size","text":"header_size(h::LasHeader) -> Int64\n\n\nGet the size of a header h in bytes\n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.point_data_offset-header","page":"Header","title":"LASDatasets.point_data_offset","text":"point_data_offset(h::LasHeader) -> Int64\n\n\nGet the offset to the first point record in a LAS file specified by a header h\n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.point_record_length-header","page":"Header","title":"LASDatasets.point_record_length","text":"point_record_length(h::LasHeader) -> Int64\n\n\nGet the number of bytes assigned to each point record in a LAS file specified by a header h\n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.point_format-header","page":"Header","title":"LASDatasets.point_format","text":"point_format(header::LasHeader) -> Any\n\n\nGet the LAS point format from a header header\n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.number_of_points-header","page":"Header","title":"LASDatasets.number_of_points","text":"number_of_points(h::LasHeader) -> Int64\n\n\nGet the number of points in a LAS file from a header h\n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.get_number_of_points_by_return-header","page":"Header","title":"LASDatasets.get_number_of_points_by_return","text":"get_number_of_points_by_return(\n    header::LasHeader\n) -> Union{NTuple{5, UInt32}, NTuple{15, UInt64}}\n\n\nGet the number of points per return for a header header\n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.number_of_vlrs-header","page":"Header","title":"LASDatasets.number_of_vlrs","text":"number_of_vlrs(h::LasHeader) -> Int64\n\n\nGet the number of Variable Length Records in a LAS file from a header h\n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.number_of_evlrs-header","page":"Header","title":"LASDatasets.number_of_evlrs","text":"number_of_evlrs(h::LasHeader) -> Int64\n\n\nGet the number of Extended Variable Length Records in a LAS file from a header h\n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.evlr_start-header","page":"Header","title":"LASDatasets.evlr_start","text":"evlr_start(header::LasHeader) -> UInt64\n\n\nGet the offset in bytes to the first EVLR in a LAS file from a header header\n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.spatial_info-header","page":"Header","title":"LASDatasets.spatial_info","text":"spatial_info(h::LasHeader) -> SpatialInfo\n\n\nGet the spatial information for point positions in a LAS file from a header h. This includes the offsets/scale factors applied to points and bounding box information\n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.num_return_channels-header","page":"Header","title":"LASDatasets.num_return_channels","text":"num_return_channels(h::LasHeader) -> Int64\n\n\nGet the number of return channels in a LAS file from a header h\n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.is_standard_gps-header","page":"Header","title":"LASDatasets.is_standard_gps","text":"If true, GPS Time is standard GPS Time (satellite GPS Time) minus 1e9. If false, GPS Time is GPS Week Time.\n\nNote that not all software sets this encoding correctly.\n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.is_wkt-header","page":"Header","title":"LASDatasets.is_wkt","text":"Check if the projection information is in WKT format (true) or GeoTIFF (false)\n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.is_internal_waveform-header","page":"Header","title":"LASDatasets.is_internal_waveform","text":"is_internal_waveform(header::LasHeader) -> Bool\n\n\nReturns whether a LAS file with header header has waveform data stored in the LAS file\n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.is_external_waveform-header","page":"Header","title":"LASDatasets.is_external_waveform","text":"is_external_waveform(header::LasHeader) -> Bool\n\n\nReturns whether a LAS file with header header has waveform data in an external file\n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.waveform_record_start-header","page":"Header","title":"LASDatasets.waveform_record_start","text":"waveform_record_start(header::LasHeader) -> UInt64\n\n\nGet the offset in bytes to the first waveform record for a LAS file with header header\n\n\n\n\n\n","category":"function"},{"location":"header/","page":"Header","title":"Header","text":"You can also modify certain fields in the header, but one should note that for some of these fields, such as those impacting the byte layout of the LAS file itself, it's better to let the system do it automatically so that your header remains consistent with your dataset.","category":"page"},{"location":"header/","page":"Header","title":"Header","text":"set_las_version!\nset_spatial_info!\nset_point_data_offset!\nset_point_record_length!\nset_point_record_count!\nset_num_vlr!\nset_num_evlr!\nset_gps_week_time_bit!\nset_gps_standard_time_bit!\nset_waveform_internal_bit!\nset_waveform_external_bit!\nset_synthetic_return_numbers_bit!\nunset_synthetic_return_numbers_bit!\nset_wkt_bit!\nunset_wkt_bit!\nset_number_of_points_by_return!","category":"page"},{"location":"header/#LASDatasets.set_las_version!-header","page":"Header","title":"LASDatasets.set_las_version!","text":"set_las_version!(\n    h::LasHeader,\n    v::VersionNumber\n) -> Union{Nothing, Tuple{Vararg{Integer}}}\n\n\nGet the LAS version in a header h\n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.set_spatial_info!-header","page":"Header","title":"LASDatasets.set_spatial_info!","text":"set_spatial_info!(\n    header::LasHeader,\n    info::SpatialInfo\n) -> SpatialInfo\n\n\nSet the spatial information associated to points in a LAS file with a header header\n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.set_point_data_offset!-header","page":"Header","title":"LASDatasets.set_point_data_offset!","text":"set_point_data_offset!(\n    header::LasHeader,\n    offset::Integer\n) -> UInt32\n\n\nSet offset to the first point record in a LAS file with a header header\n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.set_point_record_length!-header","page":"Header","title":"LASDatasets.set_point_record_length!","text":"set_point_record_length!(\n    header::LasHeader,\n    length::Integer\n) -> UInt16\n\n\nSet the number of bytes associated to each point record in a LAS file with a header header\n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.set_point_record_count!-header","page":"Header","title":"LASDatasets.set_point_record_count!","text":"set_point_record_count!(\n    header::LasHeader,\n    num_points::Integer\n) -> Union{UInt32, UInt64}\n\n\nSet the number of points in a LAS file with a header header\n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.set_num_vlr!-header","page":"Header","title":"LASDatasets.set_num_vlr!","text":"set_num_vlr!(header::LasHeader, n::Integer) -> UInt64\n\n\nSet the number of Variable Length Records in a LAS file with a header header\n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.set_num_evlr!-header","page":"Header","title":"LASDatasets.set_num_evlr!","text":"set_num_evlr!(header::LasHeader, n::Integer) -> UInt64\n\n\nSet the number of Extended Variable Length Records in a LAS file with a header header\n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.set_gps_week_time_bit!-header","page":"Header","title":"LASDatasets.set_gps_week_time_bit!","text":"set_gps_week_time_bit!(header::LasHeader) -> UInt16\n\n\nSets the bit flag indicating that the header header is in GPS week time\n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.set_gps_standard_time_bit!-header","page":"Header","title":"LASDatasets.set_gps_standard_time_bit!","text":"set_gps_standard_time_bit!(header::LasHeader) -> UInt16\n\n\nSets the bit flag indicating that the header header is in GPS standard time\n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.set_waveform_internal_bit!-header","page":"Header","title":"LASDatasets.set_waveform_internal_bit!","text":"set_waveform_internal_bit!(header::LasHeader) -> UInt16\n\n\nSets the bit flag indicating that the header header has internal waveform records\n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.set_waveform_external_bit!-header","page":"Header","title":"LASDatasets.set_waveform_external_bit!","text":"set_waveform_external_bit!(header::LasHeader) -> UInt16\n\n\nSets the bit flag indicating that the header header has external waveform records\n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.set_synthetic_return_numbers_bit!-header","page":"Header","title":"LASDatasets.set_synthetic_return_numbers_bit!","text":"set_synthetic_return_numbers_bit!(\n    header::LasHeader\n) -> UInt16\n\n\nSets the bit flag indicating that the header header has synthetically-generated return numbers\n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.unset_synthetic_return_numbers_bit!-header","page":"Header","title":"LASDatasets.unset_synthetic_return_numbers_bit!","text":"unset_synthetic_return_numbers_bit!(\n    header::LasHeader\n) -> UInt16\n\n\nSets the bit flag indicating that the header header does not have synthetically-generated return numbers\n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.set_wkt_bit!-header","page":"Header","title":"LASDatasets.set_wkt_bit!","text":"set_wkt_bit!(header::LasHeader) -> UInt16\n\n\nSets the bit flag indicating that the LAS file with header header has its coordinate reference system set as a WKT \n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.unset_wkt_bit!-header","page":"Header","title":"LASDatasets.unset_wkt_bit!","text":"unset_wkt_bit!(header::LasHeader) -> UInt16\n\n\nSets the bit flag indicating that the LAS file with header header doesn't have its coordinate reference system set as a WKT \n\n\n\n\n\n","category":"function"},{"location":"header/#LASDatasets.set_number_of_points_by_return!-header","page":"Header","title":"LASDatasets.set_number_of_points_by_return!","text":"set_number_of_points_by_return!(\n    header::LasHeader,\n    points_per_return::Tuple{Vararg{Integer, N}}\n) -> Tuple{Vararg{Integer, N}} where N\n\n\nSet the number of points per return for a header header to the values points_per_return\n\n\n\n\n\n","category":"function"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [LASDatasets]","category":"page"},{"location":"api/#ColorTypes.RGB-Tuple{Union{LasPoint10, LasPoint2, LasPoint3, LasPoint5, LasPoint7, LasPoint8}}","page":"API","title":"ColorTypes.RGB","text":"The RGB color associated with this point\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.ClassificationLookup","page":"API","title":"LASDatasets.ClassificationLookup","text":"struct ClassificationLookup\n\nA lookup record for classification labels. Each class has a short description telling you what it is.\n\nclass_description_map::Dict{UInt8, String}: Mapping of each class to a description\n\n\n\nClassificationLookup(class_description_map)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/registered_vlrs.jl:14.\n\nClassificationLookup(class_descriptions)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/registered_vlrs.jl:22.\n\n\n\n\n\n","category":"type"},{"location":"api/#LASDatasets.ExtendedPointRecord","page":"API","title":"LASDatasets.ExtendedPointRecord","text":"struct ExtendedPointRecord{TPoint, Names, Types} <: LASDatasets.LasRecord\n\nA LAS record that has a LAS point and extra user-defined point fields. Note that these must be documented as ExtraBytes VLRs in the LAS file\n\npoint::Any: The LAS point stored in this record\nuser_fields::LASDatasets.UserFields: Extra user fields associated with this point\n\n\n\n\n\n","category":"type"},{"location":"api/#LASDatasets.ExtraBytes","page":"API","title":"LASDatasets.ExtraBytes","text":"struct ExtraBytes{TData}\n\nExtra Bytes record that documents an extra field present for a point in a LAS file\n\noptions::UInt8: Specifies whether the min/max range, scale factor and offset for this field is set/meaningful and whether there is a special value to be interpreted as \"NO_DATA\"\nname::String: Name of the extra field\nno_data::Any: A value that's used if the \"NO_DATA\" flag is set in options. Use this if the point doesn't have data for this type\nmin_val::Any: Minimum value for this field, zero if not using\nmax_val::Any: Maximum value for this field, zero if not using\nscale::Any: Scale factor applied to this field, zero if not using\noffset::Any: Offset applied to this field, zero if not using\ndescription::String: Description of this extra field\n\n\n\n\n\n","category":"type"},{"location":"api/#LASDatasets.ExtraBytesCollection","page":"API","title":"LASDatasets.ExtraBytesCollection","text":"struct ExtraBytesCollection\n\nA collection of Extra Bytes records that gets packed into a VLR\n\nextra_bytes::Vector{ExtraBytes}: Collection of Extra Bytes Records, each documenting one user field in the dataset\n\n\n\nExtraBytesCollection(extra_bytes)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/registered_vlrs.jl:228.\n\nExtraBytesCollection()\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/registered_vlrs.jl:233.\n\n\n\n\n\n","category":"type"},{"location":"api/#LASDatasets.FullRecord","page":"API","title":"LASDatasets.FullRecord","text":"struct FullRecord{TPoint, Names, Types, N} <: LASDatasets.LasRecord\n\nA LAS record that has a LAS point, extra user-defined fields and additional undocumented extra bytes\n\npoint::Any: The LAS point stored in this record\nuser_fields::LASDatasets.UserFields: Extra user fields associated with this point\nundoc_bytes::StaticArraysCore.SVector{N, UInt8} where N: Array of extra bytes after the point that haven't been documented in the VLRs\n\n\n\n\n\n","category":"type"},{"location":"api/#LASDatasets.GeoAsciiParamsTag","page":"API","title":"LASDatasets.GeoAsciiParamsTag","text":"struct GeoAsciiParamsTag\n\nAn array of ASCII data that contains many strings separated by null terminator characters in ascii_params. These are referenced by position from the data in a GeoKeys record\n\n\n\n\n\n","category":"type"},{"location":"api/#LASDatasets.GeoDoubleParamsTag","page":"API","title":"LASDatasets.GeoDoubleParamsTag","text":"struct GeoDoubleParamsTag\n\nA collection of values double_params that are referenced by tag sets in a GeoKeys record\n\n\n\n\n\n","category":"type"},{"location":"api/#LASDatasets.GeoKeys","page":"API","title":"LASDatasets.GeoKeys","text":"struct GeoKeys\n\nContains the TIFF keys that defines a coordinate system. A complete description can be found in the GeoTIFF format specification. \n\nAs per the spec:\n\nkey_directory_version = 1 always\nkey_revision = 1 always\nminor_revision = 0 always\n\nThis may change in future LAS spec versions\n\n\n\n\n\n","category":"type"},{"location":"api/#LASDatasets.GeoKeys-Tuple{Integer}","page":"API","title":"LASDatasets.GeoKeys","text":"Create GeoKeys from EPSG code. Assumes CRS is projected and in metres.\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.KeyEntry","page":"API","title":"LASDatasets.KeyEntry","text":"struct KeyEntry\n\nA key entry for a piece o0f GeoTIFF data\n\nkeyid::UInt16: Defined key ID for each piece of GeoTIFF data. IDs contained in the GeoTIFF specification\ntiff_tag_location::UInt16: Indicates where the data for this key is located\ncount::UInt16: Number of characters in string for values of GeoAsciiParamsTag, otherwise is 1\nvalue_offset::UInt16: Contents vary depending on value for tiff_tag_location above\n\n\n\n\n\n","category":"type"},{"location":"api/#LASDatasets.LASDataset","page":"API","title":"LASDatasets.LASDataset","text":"mutable struct LASDataset\n\nA wrapper around a LAS dataset. Contains point cloud data in tabular format as well as metadata and VLR's/EVLR's\n\nheader::LasHeader\npointcloud::TypedTables.Table\n_user_data::Union{Missing, TypedTables.FlexTable}: Additional user data assigned to each point that aren't standard LAS fields\nvlrs::Vector{LasVariableLengthRecord}\nevlrs::Vector{LasVariableLengthRecord}\nuser_defined_bytes::Vector{UInt8}\nunit_conversion::StaticArraysCore.SVector{3, Float64}\n\n\n\n\n\n","category":"type"},{"location":"api/#LASDatasets.LasHeader","page":"API","title":"LASDatasets.LasHeader","text":"mutable struct LasHeader\n\nA LAS Header containing metadata regarding information in a LAS file See full specification here\n\nlas_version::VersionNumber: The LAS spec version this header was written in\nfile_source_id::UInt16: Numeric identifier for the source that made this file. Set to 0 if the ID is unassigned\nglobal_encoding::UInt16: A bit field used to indicate global properties. See the spec for more info\nguid_1::UInt32: First member of the Project GUID\nguid_2::UInt16: Second member of the Project GUID\nguid_3::UInt16: Third member of the Project GUID\nguid_4::NTuple{8, UInt8}: Fourth member of the Project GUID\nsystem_id::NTuple{32, UInt8}: A unique identifier indicating how the data was created\nsoftware_id::NTuple{32, UInt8}: Identifier for the software that created the LAS file\ncreation_dayofyear::UInt16: The Greenwich Mean Time (GMT) day of the year (as an unsigned short) on which the file was created\ncreation_year::UInt16: Four digit number for the year the file was created\nheader_size::UInt16: Size (in bytes) of the public header block in the LAS file. This varies depending on which LAS version was used to write it. For LAS v1.4 it's 375 bytes\ndata_offset::UInt32: Offset to the point data (in bytes) from the start of the file to the first field of the first point record\nn_vlr::UInt32: Number of Variable Length Records (VLR's) in the LAS file. These come after the header and before the point records\ndata_format_id::UInt8: Point data record format stored in the LAS file. LAS v1.4 supports formats 0-10\ndata_record_length::UInt16: Size in bytes of a point data record\nlegacy_record_count::UInt32: For maintaining legacy compatibility, the number of point records in the file (must not exceed typemax(UInt32)). Only populated for point records 0-5\nlegacy_point_return_count::NTuple{5, UInt32}: For maintaining legacy compatibility, the number of points per return (max of 5 returns, counts must not exceed typemax(UInt32)). Only populated for point records 0-5\nspatial_info::SpatialInfo: Spatial information describing the bounding range of the points, their offsets and any scaling factor applied to them\nwaveform_record_start::UInt64: Offset in bytes from the start of the file to the first byte of the Waveform Data Package Reckord\nevlr_start::UInt64: Offset in bytes from the start of the file to the first byte of the first Extended Variable Length Record (EVLR)\nn_evlr::UInt32: Number of EVLR's in the LAS file\nrecord_count::UInt64: Number of point records saved in this file (can't exceed typemax(UInt64)). This is populated for LAS v1.4\npoint_return_count::NTuple{15, UInt64}: Number of points per return saved in this file (15 returns total, counts can't exceed typemax(UInt64)). This is populated for LAS v1.4\n\n\n\n\n\n","category":"type"},{"location":"api/#LASDatasets.LasPoint","page":"API","title":"LASDatasets.LasPoint","text":"An abstract type of LasPoint. Implemented by concrete types for formats that are supported in the spec\n\n\n\n\n\n","category":"type"},{"location":"api/#LASDatasets.LasPoint0","page":"API","title":"LASDatasets.LasPoint0","text":"ASPRS LAS point data record format 0\n\n\n\n\n\n","category":"type"},{"location":"api/#LASDatasets.LasPoint1","page":"API","title":"LASDatasets.LasPoint1","text":"ASPRS LAS point data record format 1\n\n\n\n\n\n","category":"type"},{"location":"api/#LASDatasets.LasPoint10","page":"API","title":"LASDatasets.LasPoint10","text":"ASPRS LAS point data record format 10\n\n\n\n\n\n","category":"type"},{"location":"api/#LASDatasets.LasPoint2","page":"API","title":"LASDatasets.LasPoint2","text":"ASPRS LAS point data record format 2\n\n\n\n\n\n","category":"type"},{"location":"api/#LASDatasets.LasPoint3","page":"API","title":"LASDatasets.LasPoint3","text":"ASPRS LAS point data record format 3\n\n\n\n\n\n","category":"type"},{"location":"api/#LASDatasets.LasPoint4","page":"API","title":"LASDatasets.LasPoint4","text":"ASPRS LAS point data record format 4\n\n\n\n\n\n","category":"type"},{"location":"api/#LASDatasets.LasPoint5","page":"API","title":"LASDatasets.LasPoint5","text":"ASPRS LAS point data record format 5\n\n\n\n\n\n","category":"type"},{"location":"api/#LASDatasets.LasPoint6","page":"API","title":"LASDatasets.LasPoint6","text":"ASPRS LAS point data record format 6\n\n\n\n\n\n","category":"type"},{"location":"api/#LASDatasets.LasPoint7","page":"API","title":"LASDatasets.LasPoint7","text":"ASPRS LAS point data record format 7\n\n\n\n\n\n","category":"type"},{"location":"api/#LASDatasets.LasPoint8","page":"API","title":"LASDatasets.LasPoint8","text":"ASPRS LAS point data record format 8\n\n\n\n\n\n","category":"type"},{"location":"api/#LASDatasets.LasPoint9","page":"API","title":"LASDatasets.LasPoint9","text":"ASPRS LAS point data record format 9\n\n\n\n\n\n","category":"type"},{"location":"api/#LASDatasets.LasRecord","page":"API","title":"LASDatasets.LasRecord","text":"abstract type LasRecord\n\nAn abstract form of a LAS record. These are points with some additional information possibly included\n\n\n\n\n\n","category":"type"},{"location":"api/#LASDatasets.LasVariableLengthRecord","page":"API","title":"LASDatasets.LasVariableLengthRecord","text":"mutable struct LasVariableLengthRecord{TData}\n\nA variable length record included in a LAS file. This stores a particular data type TData in the record, which can be a known VLR such as a WKT transform or a custom struct. To properly define I/O methods for VLR's of custom structs, you must register which user and record ID's this struct type  will use using \n\n@register_vlr_type(TData, user_id, record_ids)\n\nAnd overload the methods read_vlr_data and write_vlr_data for your type TData\n\nSee the LAS v1.4 spec here for more details.\n\nreserved::UInt16\nuser_id::String\nrecord_id::UInt16: Numerical ID assigned to this record type\ndescription::String\ndata::Any\nextended::Bool\n\n\n\n\n\n","category":"type"},{"location":"api/#LASDatasets.OGC_WKT","page":"API","title":"LASDatasets.OGC_WKT","text":"struct OGC_WKT\n\nA Coordinate System WKT record specified by the Open Geospatial Consortium (OGC) spec\n\nwkt_str::String: The WKT formatted string for the coordinate system\nnb::Int64: Number of bytes in the WKT string\nunit::Union{Missing, String}: Units applied along the horizontal (XY) plane in this coordinate system\nvert_unit::Union{Missing, String}: Units applied along the vertical (Z) axis in this coordinate system. Note: this will not in general match the horizontal coordinate\n\n\n\n\n\n","category":"type"},{"location":"api/#LASDatasets.PointRecord","page":"API","title":"LASDatasets.PointRecord","text":"struct PointRecord{TPoint} <: LASDatasets.LasRecord\n\nA LAS record that only has a point\n\npoint::Any: The LAS point stored in this record\n\n\n\n\n\n","category":"type"},{"location":"api/#LASDatasets.SpatialInfo","page":"API","title":"LASDatasets.SpatialInfo","text":"struct SpatialInfo\n\nA wrapper around the spatial information for points in a LAS dataset, specifically the bounding box, overall translation and scaling factors applied to each point\n\n\n\n\n\n","category":"type"},{"location":"api/#LASDatasets.TextAreaDescription","page":"API","title":"LASDatasets.TextAreaDescription","text":"struct TextAreaDescription\n\nA wrapper around a text area description, which is used for providing a textual description of the content of the LAS file\n\ntxt::String: Text describing the content of the LAS file\n\n\n\n\n\n","category":"type"},{"location":"api/#LASDatasets.UndocPointRecord","page":"API","title":"LASDatasets.UndocPointRecord","text":"struct UndocPointRecord{TPoint, N} <: LASDatasets.LasRecord\n\nA LAS record that has a point as well as additional undocumented bytes (i.e. that don't have an associated ExtraBytes VLR)\n\npoint::Any: The LAS point stored in this record\nundoc_bytes::StaticArraysCore.SVector{N, UInt8} where N: Array of extra bytes after the point that haven't been documented in the VLRs\n\n\n\n\n\n","category":"type"},{"location":"api/#LASDatasets.UserFields","page":"API","title":"LASDatasets.UserFields","text":"struct UserFields{Names, Types}\n\nA collection of user-defined non-standard point fields in LAS These will be documented in the \"Extra Bytes\" VLR of your LAS file\n\nvalues::NamedTuple{Names, Types} where {Names, Types}: Mapping of field names to values. Note that values must match the corresponding field type included in the UserFields Type parameter\n\n\n\nUserFields(values)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/records.jl:12.\n\nUserFields(fields)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/records.jl:16.\n\n\n\n\n\n","category":"type"},{"location":"api/#LASDatasets.WaveformPacketDescriptor","page":"API","title":"LASDatasets.WaveformPacketDescriptor","text":"struct WaveformPacketDescriptor\n\nA Wave Packet Descriptor which contains information that describes the configuration of the waveform packets. Since systems may be configured differently at different times throughout a job, the LAS file supports 255 Waveform Packet Descriptors\n\nbits_per_sample::UInt8: Number of bits per sample. 2 to 32 bits per sample are supported\ncompression_type::UInt8: Indicates the compression algorithm used for the waveform packets associated with this descriptor. A value of 0 indicates no compression. Zero is the only value currently supported\nnum_samples::UInt32: Number of samples associated to this packet type. This always corresponds to the decompressed waveform packet\ntemporal_sample_spacing::UInt32: The temporal sample spacing in picoseconds. Example values might be 500, 1000, 2000, and so on, representing digitizer frequencies of 2 GHz, 1 GHz, and 500 MHz respectively.\ndigitizer_gain::Float64: The digitizer gain used to convert the raw digitized value to an absolute digitizer voltage using the formula: 𝑉𝑂𝐿𝑇𝑆 = 𝑂𝐹𝐹𝑆𝐸𝑇 + 𝐺𝐴𝐼𝑁 * 𝑅𝑎𝑤𝑊𝑎𝑣𝑒𝑓𝑜𝑟𝑚𝐴𝑚𝑝𝑙𝑖𝑡𝑢𝑑𝑒\n\ndigitizer_offset::Float64: The digitizer offset used to convert the raw digitized value to an absolute digitizer using formula above\n\n\n\n\n\n","category":"type"},{"location":"api/#ColorTypes.blue-Tuple{Union{LasPoint10, LasPoint2, LasPoint3, LasPoint5, LasPoint7, LasPoint8}}","page":"API","title":"ColorTypes.blue","text":"The blue image channel value associated with this point\n\n\n\n\n\n","category":"method"},{"location":"api/#ColorTypes.green-Tuple{Union{LasPoint10, LasPoint2, LasPoint3, LasPoint5, LasPoint7, LasPoint8}}","page":"API","title":"ColorTypes.green","text":"The green image channel value associated with this point\n\n\n\n\n\n","category":"method"},{"location":"api/#ColorTypes.red-Tuple{Union{LasPoint10, LasPoint2, LasPoint3, LasPoint5, LasPoint7, LasPoint8}}","page":"API","title":"ColorTypes.red","text":"The red image channel value associated with this point\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.add_column!-Union{Tuple{T}, Tuple{LASDataset, Symbol, AbstractVector{T}}} where T","page":"API","title":"LASDatasets.add_column!","text":"add_column!(\n    las::LASDataset,\n    column::Symbol,\n    values::AbstractArray{T, 1}\n)\n\n\nAdd a column with name column and set of values to a las dataset\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.add_extra_bytes!-Union{Tuple{T}, Tuple{LASDataset, Symbol, Type{T}, LasVariableLengthRecord{ExtraBytesCollection}}} where T","page":"API","title":"LASDatasets.add_extra_bytes!","text":"add_extra_bytes!(\n    las::LASDataset,\n    col_name::Symbol,\n    _::Type{T},\n    extra_bytes_vlr::LasVariableLengthRecord{ExtraBytesCollection}\n) -> Int64\n\n\nAdd an extra bytes VLR to a LAS dataset to document an extra user-field for points\n\nArguments\n\nlas : LAS dataset to add extra bytes to\ncol_name : Name to save the user field as\nT : Data type for the user field (must be a base type as specified in the spec or a static vector of one of these types)\nextra_bytes_vlr : An Extra Bytes Collection VLR that already exists in the dataset\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.add_extra_bytes_to_collection!-Union{Tuple{T}, Tuple{ExtraBytesCollection, Symbol, Type{T}}} where T","page":"API","title":"LASDatasets.add_extra_bytes_to_collection!","text":"add_extra_bytes_to_collection!(\n    collection::ExtraBytesCollection,\n    col_name::Symbol,\n    _::Type{T}\n) -> Vector{ExtraBytes}\n\n\nConstruct an extra bytes VLR with a field name col_name and data type T\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.add_vlr!-Tuple{LASDataset, LasVariableLengthRecord}","page":"API","title":"LASDatasets.add_vlr!","text":"add_vlr!(\n    las::LASDataset,\n    vlr::LasVariableLengthRecord\n) -> Any\n\n\nAdd a vlr into the set of VLRs in a LAS dataset las. Note that this will modify the header content of las, including updating its LAS version to v1.4 if vlr is extended\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.check_data_against_record_id-Tuple{Any, String, Integer, Bool}","page":"API","title":"LASDatasets.check_data_against_record_id","text":"check_data_against_record_id(\n    data,\n    user_id::String,\n    record_id::Integer,\n    extended::Bool\n)\n\n\nCheck that the user_id and record_id given are appropriate for a known VLR type data entry data\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.check_user_type-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"API","title":"LASDatasets.check_user_type","text":"check_user_type(_::Type{T})\n\n\nVerify that a user field data type T is supported as an extra byte type\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.classification-Tuple{Union{LasPoint0, LasPoint1, LasPoint2, LasPoint3, LasPoint4, LasPoint5}}","page":"API","title":"LASDatasets.classification","text":"Classification value as defined in the ASPRS classification table.\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.conversion_from_vlrs-Tuple{OGC_WKT}","page":"API","title":"LASDatasets.conversion_from_vlrs","text":"conversion_from_vlrs(\n    wkt::OGC_WKT;\n    convert_x_y_units,\n    convert_z_units\n) -> Union{Missing, StaticArraysCore.SVector{3, Float64}}\n\n\nGiven an OGC WKT coordinate system wkt, attempt to parse conversion units (to metres) with optional operator supplied overrides. Can opt to convert all axes units or just the vertical.\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.convert_units!-Tuple{AbstractVector{<:NamedTuple}, Vector{LasVariableLengthRecord}, Union{Missing, String}, Union{Missing, String}}","page":"API","title":"LASDatasets.convert_units!","text":"convert_units!(\n    pointcloud::AbstractVector{<:NamedTuple},\n    vlrs::Vector{LasVariableLengthRecord},\n    convert_x_y_units::Union{Missing, String},\n    convert_z_units::Union{Missing, String}\n) -> StaticArraysCore.SVector{3, Float64}\n\n\nConvert the position units of some pointcloud data into metres based upon the coordinate units in the LAS file's vlrs. Can override the unit conversion by manually specifying a unit to convert on the XY-plane, convert_x_y_units, and/or a unit to convert on the z-axis convert_z_units (missing if not overriding)\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.creation_day_of_year-Tuple{LasHeader}","page":"API","title":"LASDatasets.creation_day_of_year","text":"creation_day_of_year(h::LasHeader) -> UInt16\n\n\nGet the creation day of the year from a header h\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.creation_year-Tuple{LasHeader}","page":"API","title":"LASDatasets.creation_year","text":"creation_year(h::LasHeader) -> UInt16\n\n\nGet the creation year from a header h\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.data_type-Union{Tuple{ExtraBytes{TData}}, Tuple{TData}} where TData","page":"API","title":"LASDatasets.data_type","text":"data_type(_::ExtraBytes{TData}) -> Any\n\n\nGet the data type of an ExtraBytes record\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.data_type_from_ids-Tuple{String, Integer}","page":"API","title":"LASDatasets.data_type_from_ids","text":"data_type_from_ids(\n    user_id::String,\n    record_id::Integer\n) -> Any\n\n\nGet the data type associated with a particular user_id and record_id.  This is used to automatically parse VLR data types on reading\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.edge_of_flight_line-Tuple{Union{LasPoint0, LasPoint1, LasPoint2, LasPoint3, LasPoint4, LasPoint5}}","page":"API","title":"LASDatasets.edge_of_flight_line","text":"If true, it is the last point before the scanner changes direction.\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.evlr_start-Tuple{LasHeader}","page":"API","title":"LASDatasets.evlr_start","text":"evlr_start(header::LasHeader) -> UInt64\n\n\nGet the offset in bytes to the first EVLR in a LAS file from a header header\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.extract_vlr_type-Tuple{Vector{<:LasVariableLengthRecord}, String, Integer}","page":"API","title":"LASDatasets.extract_vlr_type","text":"extract_vlr_type(\n    vlrs::Vector{<:LasVariableLengthRecord},\n    user_id::String,\n    record_id::Integer\n) -> Any\n\n\nExtract all VLRs with a user_id and record_id from a collection of VLRs, vlrs\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.file_source_id-Tuple{LasHeader}","page":"API","title":"LASDatasets.file_source_id","text":"file_source_id(h::LasHeader) -> UInt16\n\n\nGet the file source ID specification version from a header h\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.flag_byte-Tuple{UInt8, UInt8, Bool, Bool}","page":"API","title":"LASDatasets.flag_byte","text":"Flag byte, as represented in the point data, built up from components\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.flag_byte-Tuple{Union{LasPoint0, LasPoint1, LasPoint2, LasPoint3, LasPoint4, LasPoint5}}","page":"API","title":"LASDatasets.flag_byte","text":"Flag byte, contains return number, number of returns, scan direction flag and edge of flight line\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.get_cols_and_extractors-Union{Tuple{TTuple}, Tuple{TPoint}, Tuple{Type{TPoint}, TTuple, SpatialInfo}} where {TPoint<:LasPoint, TTuple}","page":"API","title":"LASDatasets.get_cols_and_extractors","text":"get_cols_and_extractors(\n    _::Type{TPoint<:LasPoint},\n    required_columns,\n    xyz::SpatialInfo\n) -> Tuple{Any, Any}\n\n\nHelper function that gets the compatible column names from a user-requested set of columns and a particular point format\n\nArguments\n\nTPoint : Type of LasPoint format to check column compatibility for\nrequired_columns : Set of columns requested by the user (if empty, use all columns included in the format TPoint)\nxyz : Spatial information used to apply scaling/offset factors to point positions\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.get_evlrs-Tuple{LASDataset}","page":"API","title":"LASDatasets.get_evlrs","text":"get_evlrs(\n    las::LASDataset\n) -> Vector{LasVariableLengthRecord}\n\n\nExtract the set of Extended Variable Length Records from a LASDataset las\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.get_extra_bytes-Tuple{ExtraBytesCollection}","page":"API","title":"LASDatasets.get_extra_bytes","text":"get_extra_bytes(\n    collection::ExtraBytesCollection\n) -> Vector{ExtraBytes}\n\n\nHelper function that gets the set of Extra Bytes records from an Extra Bytes collection\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.get_field_name","page":"API","title":"LASDatasets.get_field_name","text":"get_field_name(extractor::Extractor{TColumn}, point_type::Type{TPoint}) where {TPoint, TColumn}\n\nGets the field name in the point_type for column TColumn.\n\n\n\n\n\n","category":"function"},{"location":"api/#LASDatasets.get_header-Tuple{LASDataset}","page":"API","title":"LASDatasets.get_header","text":"get_header(las::LASDataset) -> LasHeader\n\n\nExtract the header information from a LASDataset las\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.get_header_size_from_version-Tuple{VersionNumber}","page":"API","title":"LASDatasets.get_header_size_from_version","text":"get_header_size_from_version(\n    las_version::VersionNumber\n) -> Int64\n\n\nGet the header size (in bytes) for a given LAS version (as found in each version's spec)\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.get_las_version_from_data-Union{Tuple{TPoint}, Tuple{AbstractVector{<:NamedTuple}, TPoint}} where TPoint","page":"API","title":"LASDatasets.get_las_version_from_data","text":"get_las_version_from_data(\n    pc::AbstractVector{<:NamedTuple},\n    point_type\n) -> VersionNumber\n\n\nFind out the minimum las version that you can use to write the data.\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.get_num_undocumented_bytes","page":"API","title":"LASDatasets.get_num_undocumented_bytes","text":"Helper function to get the number of undocumented extra bytes associated with a LAS point record\n\nget_num_undocumented_bytes(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/records.jl:126.\n\nget_num_undocumented_bytes(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/records.jl:158.\n\nget_num_undocumented_bytes(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/records.jl:187.\n\nget_num_undocumented_bytes(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/records.jl:216.\n\n\n\n\n\n","category":"function"},{"location":"api/#LASDatasets.get_num_user_field_bytes","page":"API","title":"LASDatasets.get_num_user_field_bytes","text":"Helper function to get the number of bytes making up user-defined fields associated with a LAS point record\n\nget_num_user_field_bytes(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/records.jl:125.\n\nget_num_user_field_bytes(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/records.jl:155.\n\nget_num_user_field_bytes(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/records.jl:186.\n\nget_num_user_field_bytes(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/records.jl:213.\n\n\n\n\n\n","category":"function"},{"location":"api/#LASDatasets.get_number_of_points_by_return-Tuple{LasHeader}","page":"API","title":"LASDatasets.get_number_of_points_by_return","text":"get_number_of_points_by_return(\n    header::LasHeader\n) -> Union{NTuple{5, UInt32}, NTuple{15, UInt64}}\n\n\nGet the number of points per return for a header header\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.get_point-Tuple{LASDatasets.LasRecord}","page":"API","title":"LASDatasets.get_point","text":"get_point(record::LASDatasets.LasRecord) -> Any\n\n\nHelper function to get the LAS point from a LAS point record\n\nget_point(record)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/records.jl:75.\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.get_point_format","page":"API","title":"LASDatasets.get_point_format","text":"Helper function to get the LAS point format associated with a LAS point record\n\nget_point_format(table)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/parse_points.jl:19.\n\nget_point_format(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/points.jl:230.\n\nget_point_format(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/points.jl:231.\n\nget_point_format(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/points.jl:232.\n\nget_point_format(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/points.jl:233.\n\nget_point_format(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/points.jl:234.\n\nget_point_format(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/points.jl:235.\n\nget_point_format(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/points.jl:236.\n\nget_point_format(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/points.jl:237.\n\nget_point_format(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/points.jl:238.\n\nget_point_format(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/points.jl:239.\n\nget_point_format(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/points.jl:240.\n\nget_point_format(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/points.jl:252.\n\nget_point_format(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/records.jl:124.\n\nget_point_format(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/records.jl:154.\n\nget_point_format(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/records.jl:185.\n\nget_point_format(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/records.jl:212.\n\n\n\n\n\n","category":"function"},{"location":"api/#LASDatasets.get_point_format-Tuple{AbstractVector{<:NamedTuple}}","page":"API","title":"LASDatasets.get_point_format","text":"get_point_format(table::AbstractVector{<:NamedTuple}) -> Any\n\n\nGet the minimum point format that is compatible with the contents of a point cloud in a table\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.get_point_format-Tuple{Type{LasPoint{0}}}","page":"API","title":"LASDatasets.get_point_format","text":"get_point_format(_::Type{LasPoint{0}}) -> Type{LasPoint0}\n\n\nGet the concrete point format struct from an abstract LasPoint type\n\nget_point_format(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/points.jl:230.\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.get_point_format_id-Union{Tuple{Type{T}}, Tuple{T}, Tuple{N}} where {N, T<:LasPoint{N}}","page":"API","title":"LASDatasets.get_point_format_id","text":"get_point_format_id(_::Type{T<:LasPoint{N}}) -> Any\n\n\nGet the numeric format ID corresponding to a particular point format\n\nget_point_format_id(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/points.jl:249.\n\nget_point_format_id(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/points.jl:250.\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.get_pointcloud-Tuple{LASDataset}","page":"API","title":"LASDatasets.get_pointcloud","text":"get_pointcloud(las::LASDataset) -> TypedTables.Table\n\n\nExtract point cloud data as a Table from a LASDataset las\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.get_record_bytes-Union{Tuple{TRecord}, Tuple{StructArrays.StructVector{TRecord}, Vector{LasVariableLengthRecord}}} where TRecord<:LASDatasets.LasRecord","page":"API","title":"LASDatasets.get_record_bytes","text":"get_record_bytes(\n    records::StructArrays.StructArray{TRecord<:LASDatasets.LasRecord, 1},\n    vlrs::Vector{LasVariableLengthRecord}\n) -> Any\n\n\nConstruct an array of bytes that correctly encodes the information stored in a set of LAS records according to the spec\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.get_unit_conversion-Tuple{LASDataset}","page":"API","title":"LASDatasets.get_unit_conversion","text":"get_unit_conversion(\n    las::LASDataset\n) -> StaticArraysCore.SVector{3, Float64}\n\n\nGet the unit factor conversion that was applied to this dataset when ingested\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.get_user_defined_bytes-Tuple{LASDataset}","page":"API","title":"LASDatasets.get_user_defined_bytes","text":"get_user_defined_bytes(las::LASDataset) -> Vector{UInt8}\n\n\nExtract the set of user-defined bytes from a LASDataset las\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.get_user_field_map-Tuple{Union{Tuple, Vector}}","page":"API","title":"LASDatasets.get_user_field_map","text":"get_user_field_map(\n    user_fields::Union{Tuple, Vector}\n) -> Dict{Symbol, Vector{Symbol}}\n\n\nHelper function that maps a user field name to the set of user field names in the Extra Bytes VLRs that are entries for this field. If a user field is a scalar, this will simply map user_field => [user_field]. If it is a vector, it will map col => [\"col [0]\", \"col [1]\", ..., \"col [N]\"]\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.get_user_fields_for_table-Union{Tuple{TTuple}, Tuple{TRecord}, Tuple{Vector{TRecord}, Tuple, TTuple}} where {TRecord<:Union{LASDatasets.ExtendedPointRecord, LASDatasets.FullRecord}, TTuple}","page":"API","title":"LASDatasets.get_user_fields_for_table","text":"get_user_fields_for_table(\n    records::Array{TRecord<:Union{LASDatasets.ExtendedPointRecord, LASDatasets.FullRecord}, 1},\n    Names::Tuple,\n    required_columns\n) -> Tuple{Vector{Symbol}, Tuple}\n\n\nHelper function that finds the names of user-defined point fields that have been requested by a user and group them together if they form arrays in the output data. Note according to spec that user-defined array field names must be of the form col [0], col[1], ..., col[N] where N is the dimension of the user field\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.get_vlrs-Tuple{LASDataset}","page":"API","title":"LASDatasets.get_vlrs","text":"get_vlrs(las::LASDataset) -> Vector{LasVariableLengthRecord}\n\n\nExtract the set of Variable Length Records from a LASDataset las\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.global_encoding-Tuple{LasHeader}","page":"API","title":"LASDatasets.global_encoding","text":"global_encoding(h::LasHeader) -> UInt16\n\n\nGet the global properties bit vector from a header h\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.group_user_fields-Tuple{Dict{Symbol, Vector}, Dict{Symbol, Vector{Symbol}}}","page":"API","title":"LASDatasets.group_user_fields","text":"group_user_fields(\n    raw_user_data::Dict{Symbol, Vector},\n    user_field_map::Dict{Symbol, Vector{Symbol}}\n) -> Tuple\n\n\nHelper function that groups raw user field data into either a vector of scalars or vector of vectors\n\nArguments\n\nraw_user_data : Maps the raw user field names (as they appear in the Extra Bytes VLRs, e.g. \"col\" for scalar or \"col [n]\" for entry in array) to their data in each point record\nuser_field_map : Maps each user field base name to the collection of raw user field names composing it\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.header_size-Tuple{LasHeader}","page":"API","title":"LASDatasets.header_size","text":"header_size(h::LasHeader) -> Int64\n\n\nGet the size of a header h in bytes\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.is_external_waveform-Tuple{LasHeader}","page":"API","title":"LASDatasets.is_external_waveform","text":"is_external_waveform(header::LasHeader) -> Bool\n\n\nReturns whether a LAS file with header header has waveform data in an external file\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.is_internal_waveform-Tuple{LasHeader}","page":"API","title":"LASDatasets.is_internal_waveform","text":"is_internal_waveform(header::LasHeader) -> Bool\n\n\nReturns whether a LAS file with header header has waveform data stored in the LAS file\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.is_srs-Tuple{LasVariableLengthRecord}","page":"API","title":"LASDatasets.is_srs","text":"Test whether a vlr is a GeoKeyDirectoryTag, GeoDoubleParamsTag or GeoAsciiParamsTag\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.is_standard_gps-Tuple{LasHeader}","page":"API","title":"LASDatasets.is_standard_gps","text":"If true, GPS Time is standard GPS Time (satellite GPS Time) minus 1e9. If false, GPS Time is GPS Week Time.\n\nNote that not all software sets this encoding correctly.\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.is_wkt-Tuple{LasHeader}","page":"API","title":"LASDatasets.is_wkt","text":"Check if the projection information is in WKT format (true) or GeoTIFF (false)\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.key_point-Tuple{Union{LasPoint0, LasPoint1, LasPoint2, LasPoint3, LasPoint4, LasPoint5}}","page":"API","title":"LASDatasets.key_point","text":"If true, this point is considered to be a model key-point.\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.las_record-Union{Tuple{N}, Tuple{TPoint}, Tuple{Type{TPoint}, NamedTuple, SpatialInfo, StaticArraysCore.SVector{N, UInt8}}, Tuple{Type{TPoint}, NamedTuple, SpatialInfo, StaticArraysCore.SVector{N, UInt8}, Any}} where {TPoint<:LasPoint, N}","page":"API","title":"LASDatasets.las_record","text":"las_record(\n    ::Type{TPoint<:LasPoint},\n    p::NamedTuple,\n    xyz::SpatialInfo,\n    undoc_bytes::StaticArraysCore.SArray{Tuple{N}, UInt8, 1, N}\n) -> Any\nlas_record(\n    ::Type{TPoint<:LasPoint},\n    p::NamedTuple,\n    xyz::SpatialInfo,\n    undoc_bytes::StaticArraysCore.SArray{Tuple{N}, UInt8, 1, N},\n    user_fields\n) -> Any\n\n\nConstruct a LAS record for a point in a tabular point cloud\n\nArguments\n\nTPoint : Type of the LAS point to construct from this point data\np : Point entry in a tabular point cloud\nxyz : Spatial information about scaling, offsets and bounding ranges of the point cloud\nuser_fields : Tuple of user-defined fields to append to the point record (empty if not using). Note: these must match what's in your point p. Default ()\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.las_version-Tuple{LasHeader}","page":"API","title":"LASDatasets.las_version","text":"las_version(h::LasHeader) -> VersionNumber\n\n\nGet the LAS specification version from a header h\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.laspoint","page":"API","title":"LASDatasets.laspoint","text":"A convenience function that creates a LasPoint from a given struct and some spatial information\n\nlaspoint(_, p, xyz)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/parse_points.jl:7.\n\nlaspoint(_, p, xyz)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/parse_points.jl:197.\n\nlaspoint(_, p, xyz)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/parse_points.jl:228.\n\nlaspoint(_, p, xyz)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/parse_points.jl:260.\n\nlaspoint(_, p, xyz)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/parse_points.jl:295.\n\nlaspoint(_, p, xyz)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/parse_points.jl:332.\n\nlaspoint(_, p, xyz)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/parse_points.jl:376.\n\nlaspoint(_, p, xyz)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/parse_points.jl:447.\n\nlaspoint(_, p, xyz)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/parse_points.jl:481.\n\nlaspoint(_, p, xyz)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/parse_points.jl:521.\n\nlaspoint(_, p, xyz)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/parse_points.jl:563.\n\nlaspoint(_, p, xyz)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/parse_points.jl:611.\n\n\n\n\n\n","category":"function"},{"location":"api/#LASDatasets.lasversion_for_point","page":"API","title":"LASDatasets.lasversion_for_point","text":"Get the LAS spec version that matches the point type T\n\n\n\n\n\n","category":"function"},{"location":"api/#LASDatasets.load_header-Tuple{AbstractString}","page":"API","title":"LASDatasets.load_header","text":"load_header(file_name::AbstractString) -> LasHeader\n\n\nIngest a LAS header from a file\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.load_las-Union{Tuple{AbstractString}, Tuple{TFields}, Tuple{AbstractString, TFields}} where TFields","page":"API","title":"LASDatasets.load_las","text":"load_las(file_name::AbstractString; ...) -> LASDataset\nload_las(\n    file_name::AbstractString,\n    fields;\n    kwargs...\n) -> LASDataset\n\n\nLoad a LAS dataset from a source file\n\nArguments\n\nfile_name : Name of the LAS file to extract data from\nfields : Name of the LAS point fields to extract as columns in the output data. If set to nothing, ingest all available columns. Default DEFAULT_LAS_COLUMNS\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.load_pointcloud","page":"API","title":"LASDatasets.load_pointcloud","text":"load_pointcloud(\n    file_name::AbstractString;\n    ...\n) -> TypedTables.Table{_A, _B, NamedTuple{names, T}} where {_A<:NamedTuple, _B, names, T<:Tuple{Vararg{AbstractArray{<:Any, _B}}}}\nload_pointcloud(\n    file_name::AbstractString,\n    fields::Union{Nothing, AbstractVector{Symbol}};\n    kwargs...\n) -> TypedTables.Table{_A, _B, NamedTuple{names, T}} where {_A<:NamedTuple, _B, names, T<:Tuple{Vararg{AbstractArray{<:Any, _B}}}}\n\n\nIngest LAS point data in a tabular format\n\n\n\n\n\n","category":"function"},{"location":"api/#LASDatasets.load_vlrs-Tuple{AbstractString, LasHeader}","page":"API","title":"LASDatasets.load_vlrs","text":"load_vlrs(\n    file_name::AbstractString,\n    header::LasHeader\n) -> Any\n\n\nIngest a set of variable length records from a LAS file\n\nload_vlrs(file_name, header)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/read.jl:57.\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.make_consistent_header!-Tuple{LasHeader, AbstractVector{<:NamedTuple}, Vector{<:LasVariableLengthRecord}, Vector{<:LasVariableLengthRecord}, Vector{UInt8}}","page":"API","title":"LASDatasets.make_consistent_header!","text":"make_consistent_header!(\n    header::LasHeader,\n    pointcloud::AbstractVector{<:NamedTuple},\n    vlrs::Vector{<:LasVariableLengthRecord},\n    evlrs::Vector{<:LasVariableLengthRecord},\n    user_defined_bytes::Vector{UInt8}\n) -> UInt16\n\n\nEnsure that a LAS header is consistent with a given pointcloud data coupled with sets of vlrs, evlrs and user_defined_bytes\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.make_consistent_header-Union{Tuple{TPoint}, Tuple{AbstractVector{<:NamedTuple}, Type{TPoint}, Vector{<:LasVariableLengthRecord}, Vector{<:LasVariableLengthRecord}, Vector{UInt8}, Real}} where TPoint<:LasPoint","page":"API","title":"LASDatasets.make_consistent_header","text":"make_consistent_header(\n    pointcloud::AbstractVector{<:NamedTuple},\n    point_format::Type{TPoint<:LasPoint},\n    vlrs::Vector{<:LasVariableLengthRecord},\n    evlrs::Vector{<:LasVariableLengthRecord},\n    user_defined_bytes::Vector{UInt8},\n    scale::Real\n) -> LasHeader\n\n\nConstruct a LAS header that is consistent with a given pointcloud data in a specific LAS point_format, coupled with sets of vlrs, evlrs and user_defined_bytes \n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.make_table-Union{Tuple{TTuple}, Tuple{TPoint}, Tuple{Array{LASDatasets.PointRecord{TPoint}, 1}, TTuple, SpatialInfo}} where {TPoint<:LasPoint, TTuple}","page":"API","title":"LASDatasets.make_table","text":"make_table(\n    records::Array{LASDatasets.PointRecord{TPoint<:LasPoint}, 1},\n    required_columns,\n    xyz::SpatialInfo\n) -> TypedTables.Table{_A, _B, NamedTuple{names, T}} where {_A<:NamedTuple, _B, names, T<:Tuple{Vararg{AbstractArray{<:Any, _B}}}}\n\n\nConvert a collection of LAS point records into a Table with the desired columns\n\nArguments\n\nrecords : A collection of LasRecords that have been read from a LAS file\nrequired_columns : Set of columns to include in the table being constructed\nxyz : Spatial information used to apply scaling/offset factors to point positions\n\nmake_table(records, required_columns, xyz)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/read.jl:144.\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.merge_column!-Tuple{LASDataset, Symbol, AbstractVector}","page":"API","title":"LASDatasets.merge_column!","text":"merge_column!(\n    las::LASDataset,\n    column::Symbol,\n    values::AbstractVector\n) -> Any\n\n\nMerge a column with name column and a set of values into a las dataset\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.name-Tuple{ExtraBytes}","page":"API","title":"LASDatasets.name","text":"name(e::ExtraBytes) -> String\n\n\nGet the name of an additional user field that's documented by an extra bytes record e\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.num_return_channels-Tuple{LasHeader}","page":"API","title":"LASDatasets.num_return_channels","text":"num_return_channels(h::LasHeader) -> Int64\n\n\nGet the number of return channels in a LAS file from a header h\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.number_of_evlrs-Tuple{LasHeader}","page":"API","title":"LASDatasets.number_of_evlrs","text":"number_of_evlrs(h::LasHeader) -> Int64\n\n\nGet the number of Extended Variable Length Records in a LAS file from a header h\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.number_of_points-Tuple{LasHeader}","page":"API","title":"LASDatasets.number_of_points","text":"number_of_points(h::LasHeader) -> Int64\n\n\nGet the number of points in a LAS file from a header h\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.number_of_returns-Tuple{Union{LasPoint0, LasPoint1, LasPoint2, LasPoint3, LasPoint4, LasPoint5}}","page":"API","title":"LASDatasets.number_of_returns","text":"The total number of returns for a given pulse.\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.number_of_vlrs-Tuple{LasHeader}","page":"API","title":"LASDatasets.number_of_vlrs","text":"number_of_vlrs(h::LasHeader) -> Int64\n\n\nGet the number of Variable Length Records in a LAS file from a header h\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.official_record_ids-Union{Tuple{Type{TData}}, Tuple{TData}} where TData","page":"API","title":"LASDatasets.official_record_ids","text":"official_record_ids(_::Type{TData}) -> UInt16\n\n\nThe registered record IDs associated to VLRs of this record type TData\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.official_user_id-Union{Tuple{Type{TData}}, Tuple{TData}} where TData","page":"API","title":"LASDatasets.official_user_id","text":"official_user_id(_::Type{TData}) -> String\n\n\nThe registered user ID associated to VLRs of this record type TData. Currently assuming one user ID per data type\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.overlap-Tuple{Union{LasPoint10, LasPoint6, LasPoint7, LasPoint8, LasPoint9}}","page":"API","title":"LASDatasets.overlap","text":"If true, this point is classified as an overlapping point with another data set\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.point_data_offset-Tuple{LasHeader}","page":"API","title":"LASDatasets.point_data_offset","text":"point_data_offset(h::LasHeader) -> Int64\n\n\nGet the offset to the first point record in a LAS file specified by a header h\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.point_format-Tuple{LasHeader}","page":"API","title":"LASDatasets.point_format","text":"point_format(header::LasHeader) -> Any\n\n\nGet the LAS point format from a header header\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.point_record_length-Tuple{LasHeader}","page":"API","title":"LASDatasets.point_record_length","text":"point_record_length(h::LasHeader) -> Int64\n\n\nGet the number of bytes assigned to each point record in a LAS file specified by a header h\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.raw_classification-Tuple{UInt8, Bool, Bool, Bool}","page":"API","title":"LASDatasets.raw_classification","text":"Raw classification byte in LAS1.1-1.3, as represented in the point data, is built up from components\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.read_final_fields-Tuple{IO, VersionNumber, Bool}","page":"API","title":"LASDatasets.read_final_fields","text":"read_final_fields(\n    io::IO,\n    las_version::VersionNumber,\n    is_at_least_v14::Bool\n) -> Tuple{Any, Tuple{Vararg{UInt32}}, SpatialInfo, Any, Any, Any, Any, Tuple{Vararg{UInt64}}}\n\n\nHelper function that reads the last few fields (from legacy record count to point return count) of a LAS header from an io\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.read_las_data-Union{Tuple{TTuple}, Tuple{TIO}, Tuple{TIO, TTuple}} where {TIO<:IO, TTuple}","page":"API","title":"LASDatasets.read_las_data","text":"read_las_data(io; ...) -> LASDataset\nread_las_data(\n    io::IO,\n    required_columns;\n    convert_to_metres,\n    convert_x_y_units,\n    convert_z_units\n) -> LASDataset\n\n\nRead LAS data from an IO source\n\nArguments\n\nio : IO Channel to read the data in from\nrequired_columns : Point record fields to extract as columns in the output data, default DEFAULT_LAS_COLUMNS\n\nKeyword Arguments\n\nconvrt_to_metres : Flag indicating that point coordinates will be converted to metres upon reading, default true\nconvert_x_y_units : Name of the units used to measure point coordinates in the LAS file that will be converted to metres when ingested. Set to missing for no conversion (default missing)\nconvert_z_units : Name of the units on the z-axis in the LAS file that will be converted to metres when ingested. Set to missing for no conversion (default missing)\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.read_vlr_data-Union{Tuple{TData}, Tuple{IO, Type{TData}, Integer}} where TData","page":"API","title":"LASDatasets.read_vlr_data","text":"read_vlr_data(\n    io::IO,\n    _::Type{TData},\n    nb::Integer\n) -> OGC_WKT\n\n\nRead data of type TData that belongs to a VLR by readig nb bytes from an io.  By default this will call Base.read, but for more specific read methods this will need to be overloaded for your type\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.readstring-Tuple{Any, Integer}","page":"API","title":"LASDatasets.readstring","text":"readstring(io, nb::Integer) -> Any\n\n\nRead a string from nb bytes from an IO channel io\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.record_format","page":"API","title":"LASDatasets.record_format","text":"record_format(header::LasHeader) -> Type\nrecord_format(\n    header::LasHeader,\n    extra_bytes::Vector{<:ExtraBytes}\n) -> Type\n\n\nGet the appropriate LAS record format for a LAS header and a (possibly empty) set of extra_bytes that document any optional user fields to include\n\n\n\n\n\n","category":"function"},{"location":"api/#LASDatasets.remove_vlr!-Tuple{LASDataset, LasVariableLengthRecord}","page":"API","title":"LASDatasets.remove_vlr!","text":"remove_vlr!(\n    las::LASDataset,\n    vlr::LasVariableLengthRecord\n) -> Union{Nothing, Int64}\n\n\nRemove a vlr from set of VLRs in a LAS dataset las. Note that this will modify the header content of las\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.save_las-Tuple{AbstractString, AbstractVector{<:NamedTuple}}","page":"API","title":"LASDatasets.save_las","text":"save_las(\n    file_name::AbstractString,\n    pointcloud::AbstractVector{<:NamedTuple};\n    vlrs,\n    evlrs,\n    user_defined_bytes,\n    scale,\n    kwargs...\n)\n\n\nSaves a pointcloud to LAS or LAZ. The appropriate LAS version and point format is inferred from the contents of your point cloud\n\nArguments\n\nfile_name : Name of the LAS file to save the data into\npointcloud : Point cloud data in a tabular format\n\nKeyword Arguments\n\nvlrs : Collection of Variable Length Records to write to the LAS file, default LasVariableLengthRecord[]\nevlrs : Collection of Extended Variable Length Records to write to the LAS file, default LasVariableLengthRecord[]\nuser_defined_bytes : Any user-defined bytes to write in between the VLRs and point records, default UInt8[]\nscale : Scaling factor applied to points on writing, default LASDatasets.POINT_SCALE\n\n\n\nsave_las(\n    file_name,\n    pointcloud;\n    vlrs,\n    evlrs,\n    user_defined_bytes,\n    scale,\n    kwargs...\n)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/write.jl:18.\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.scan_angle-Tuple{Union{LasPoint0, LasPoint1, LasPoint2, LasPoint3, LasPoint4, LasPoint5}}","page":"API","title":"LASDatasets.scan_angle","text":"Angle at which the laser point was output, including the roll of the aircraft.\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.scan_direction-Tuple{Union{LasPoint0, LasPoint1, LasPoint2, LasPoint3, LasPoint4, LasPoint5}}","page":"API","title":"LASDatasets.scan_direction","text":"If true, the scanner mirror was traveling from left to right at the time of the output pulse.\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.set_gps_standard_time_bit!-Tuple{LasHeader}","page":"API","title":"LASDatasets.set_gps_standard_time_bit!","text":"set_gps_standard_time_bit!(header::LasHeader) -> UInt16\n\n\nSets the bit flag indicating that the header header is in GPS standard time\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.set_gps_week_time_bit!-Tuple{LasHeader}","page":"API","title":"LASDatasets.set_gps_week_time_bit!","text":"set_gps_week_time_bit!(header::LasHeader) -> UInt16\n\n\nSets the bit flag indicating that the header header is in GPS week time\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.set_las_version!-Tuple{LasHeader, VersionNumber}","page":"API","title":"LASDatasets.set_las_version!","text":"set_las_version!(\n    h::LasHeader,\n    v::VersionNumber\n) -> Union{Nothing, Tuple{Vararg{Integer}}}\n\n\nGet the LAS version in a header h\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.set_num_evlr!-Tuple{LasHeader, Integer}","page":"API","title":"LASDatasets.set_num_evlr!","text":"set_num_evlr!(header::LasHeader, n::Integer) -> UInt64\n\n\nSet the number of Extended Variable Length Records in a LAS file with a header header\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.set_num_vlr!-Tuple{LasHeader, Integer}","page":"API","title":"LASDatasets.set_num_vlr!","text":"set_num_vlr!(header::LasHeader, n::Integer) -> UInt64\n\n\nSet the number of Variable Length Records in a LAS file with a header header\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.set_number_of_points_by_return!-Union{Tuple{N}, Tuple{LasHeader, Tuple{Vararg{Integer, N}}}} where N","page":"API","title":"LASDatasets.set_number_of_points_by_return!","text":"set_number_of_points_by_return!(\n    header::LasHeader,\n    points_per_return::Tuple{Vararg{Integer, N}}\n) -> Tuple{Vararg{Integer, N}} where N\n\n\nSet the number of points per return for a header header to the values points_per_return\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.set_point_data_offset!-Tuple{LasHeader, Integer}","page":"API","title":"LASDatasets.set_point_data_offset!","text":"set_point_data_offset!(\n    header::LasHeader,\n    offset::Integer\n) -> UInt32\n\n\nSet offset to the first point record in a LAS file with a header header\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.set_point_record_count!-Tuple{LasHeader, Integer}","page":"API","title":"LASDatasets.set_point_record_count!","text":"set_point_record_count!(\n    header::LasHeader,\n    num_points::Integer\n) -> Union{UInt32, UInt64}\n\n\nSet the number of points in a LAS file with a header header\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.set_point_record_length!-Tuple{LasHeader, Integer}","page":"API","title":"LASDatasets.set_point_record_length!","text":"set_point_record_length!(\n    header::LasHeader,\n    length::Integer\n) -> UInt16\n\n\nSet the number of bytes associated to each point record in a LAS file with a header header\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.set_spatial_info!-Tuple{LasHeader, SpatialInfo}","page":"API","title":"LASDatasets.set_spatial_info!","text":"set_spatial_info!(\n    header::LasHeader,\n    info::SpatialInfo\n) -> SpatialInfo\n\n\nSet the spatial information associated to points in a LAS file with a header header\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.set_superseded!-Tuple{LASDataset, LasVariableLengthRecord}","page":"API","title":"LASDatasets.set_superseded!","text":"set_superseded!(\n    las::LASDataset,\n    vlr::LasVariableLengthRecord\n) -> UInt16\n\n\nMark a VLR vlr as superseded in a dataset las\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.set_superseded!-Tuple{LasVariableLengthRecord}","page":"API","title":"LASDatasets.set_superseded!","text":"set_superseded!(vlr::LasVariableLengthRecord) -> UInt16\n\n\nMark a VLR as \"superseded\", meaning it has been replaced by a newer record when modifying the LAS file. Note: The LAS spec only allows for 1 superseded record per LAS file\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.set_synthetic_return_numbers_bit!-Tuple{LasHeader}","page":"API","title":"LASDatasets.set_synthetic_return_numbers_bit!","text":"set_synthetic_return_numbers_bit!(\n    header::LasHeader\n) -> UInt16\n\n\nSets the bit flag indicating that the header header has synthetically-generated return numbers\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.set_waveform_external_bit!-Tuple{LasHeader}","page":"API","title":"LASDatasets.set_waveform_external_bit!","text":"set_waveform_external_bit!(header::LasHeader) -> UInt16\n\n\nSets the bit flag indicating that the header header has external waveform records\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.set_waveform_internal_bit!-Tuple{LasHeader}","page":"API","title":"LASDatasets.set_waveform_internal_bit!","text":"set_waveform_internal_bit!(header::LasHeader) -> UInt16\n\n\nSets the bit flag indicating that the header header has internal waveform records\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.set_wkt_bit!-Tuple{LasHeader}","page":"API","title":"LASDatasets.set_wkt_bit!","text":"set_wkt_bit!(header::LasHeader) -> UInt16\n\n\nSets the bit flag indicating that the LAS file with header header has its coordinate reference system set as a WKT \n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.software_id-Tuple{LasHeader}","page":"API","title":"LASDatasets.software_id","text":"software_id(h::LasHeader) -> String\n\n\nGet the software ID from a header h\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.spatial_info-Tuple{LasHeader}","page":"API","title":"LASDatasets.spatial_info","text":"spatial_info(h::LasHeader) -> SpatialInfo\n\n\nGet the spatial information for point positions in a LAS file from a header h. This includes the offsets/scale factors applied to points and bounding box information\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.split_column_name-Tuple{Symbol, Integer}","page":"API","title":"LASDatasets.split_column_name","text":"split_column_name(col::Symbol, dim::Integer) -> Any\n\n\nHelper function that returns a list of extra bytes VLR field names for each entry in a user-defined array with column name col and dimension dim\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.synthetic-Tuple{Union{LasPoint0, LasPoint1, LasPoint2, LasPoint3, LasPoint4, LasPoint5}}","page":"API","title":"LASDatasets.synthetic","text":"If true, the point was not created from lidar collection\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.system_id-Tuple{LasHeader}","page":"API","title":"LASDatasets.system_id","text":"system_id(h::LasHeader) -> String\n\n\nGet the system ID from a header h\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.units_to_conversion","page":"API","title":"LASDatasets.units_to_conversion","text":"units_to_conversion(\n    unit::Union{Missing, String}\n) -> Union{Missing, StaticArraysCore.SVector{3, Float64}}\nunits_to_conversion(\n    unit::Union{Missing, String},\n    v_unit::Union{Missing, String}\n) -> Missing\n\n\nParse the specified units into a conversion vector.\n\n\n\n\n\n","category":"function"},{"location":"api/#LASDatasets.unset_synthetic_return_numbers_bit!-Tuple{LasHeader}","page":"API","title":"LASDatasets.unset_synthetic_return_numbers_bit!","text":"unset_synthetic_return_numbers_bit!(\n    header::LasHeader\n) -> UInt16\n\n\nSets the bit flag indicating that the header header does not have synthetically-generated return numbers\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.unset_waveform_bits!-Tuple{LasHeader}","page":"API","title":"LASDatasets.unset_waveform_bits!","text":"unset_waveform_bits!(header::LasHeader) -> UInt16\n\n\nUnset all bit flags in a header to do with waveform information\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.unset_wkt_bit!-Tuple{LasHeader}","page":"API","title":"LASDatasets.unset_wkt_bit!","text":"unset_wkt_bit!(header::LasHeader) -> UInt16\n\n\nSets the bit flag indicating that the LAS file with header header doesn't have its coordinate reference system set as a WKT \n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.waveform_record_start-Tuple{LasHeader}","page":"API","title":"LASDatasets.waveform_record_start","text":"waveform_record_start(header::LasHeader) -> UInt64\n\n\nGet the offset in bytes to the first waveform record for a LAS file with header header\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.withheld-Tuple{Union{LasPoint0, LasPoint1, LasPoint2, LasPoint3, LasPoint4, LasPoint5}}","page":"API","title":"LASDatasets.withheld","text":"If true, this point should not be included in processing\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.write_las-Union{Tuple{TPoint}, Tuple{IO, AbstractVector{<:NamedTuple}, Type{TPoint}, Vector{<:LasVariableLengthRecord}, Vector{<:LasVariableLengthRecord}, Vector{UInt8}, Real}} where TPoint","page":"API","title":"LASDatasets.write_las","text":"write_las(\n    io::IO,\n    pointcloud::AbstractVector{<:NamedTuple},\n    point_format::Type{TPoint},\n    vlrs::Vector{<:LasVariableLengthRecord},\n    evlrs::Vector{<:LasVariableLengthRecord},\n    user_defined_bytes::Vector{UInt8},\n    scale::Real\n)\n\n\nWrite a pointcloud and additional VLR's and user-defined bytes to an IO stream in a LAS format\n\nArguments\n\nio : IO channel to write the data to\npointcloud : Pointcloud data in a tabular format to write\nvlrs : Collection of Variable Length Records to write to io\nevlrs : Collection of Extended Variable Length Records to write to io\nuser_defined_bytes : Any user-defined bytes to write in between the VLRs and point records\nscale : Scaling factor applied to points on writing\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.write_vlr_data-Union{Tuple{TData}, Tuple{IO, TData}} where TData","page":"API","title":"LASDatasets.write_vlr_data","text":"write_vlr_data(io::IO, data) -> Any\n\n\nWrite data of type TData that belongs to a VLR to an io.  By default this will call Base.write, but for more specific write methods this will need to be overloaded for your type\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.writestring-Tuple{Any, AbstractString, Integer}","page":"API","title":"LASDatasets.writestring","text":"writestring(io, str::AbstractString, nb::Integer) -> Any\n\n\nWrite a string str to an IO channel io, writing exactly nb bytes (padding if str is too short)\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.xcoord-Tuple{LasPoint, LasHeader}","page":"API","title":"LASDatasets.xcoord","text":"X coordinate (Float64), apply scale and offset according to the header\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.xcoord-Tuple{Real, LasHeader}","page":"API","title":"LASDatasets.xcoord","text":"X value (Int32), as represented in the point data, reversing the offset and scale from the header\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.ycoord-Tuple{LasPoint, LasHeader}","page":"API","title":"LASDatasets.ycoord","text":"Y coordinate (Float64), apply scale and offset according to the header\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.ycoord-Tuple{Real, LasHeader}","page":"API","title":"LASDatasets.ycoord","text":"Y value (Int32), as represented in the point data, reversing the offset and scale from the header\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.zcoord-Tuple{LasPoint, LasHeader}","page":"API","title":"LASDatasets.zcoord","text":"Z coordinate (Float64), apply scale and offset according to the header\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.zcoord-Tuple{Real, LasHeader}","page":"API","title":"LASDatasets.zcoord","text":"Z value (Int32), as represented in the point data, reversing the offset and scale from the header\n\n\n\n\n\n","category":"method"},{"location":"api/#LASDatasets.@register_vlr_type-Tuple{Any, Any, Any}","page":"API","title":"LASDatasets.@register_vlr_type","text":"Register a new VLR data type type by associating it with an official user_id and set of record_ids \n\n\n\n\n\n","category":"macro"},{"location":"interface/#High-Level-Interface","page":"Interface","title":"High-Level Interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"LASDatasets.jl provides a number of high-level functions to easily manipulate your LAS data. ","category":"page"},{"location":"interface/#*LAS*-Datasets","page":"Interface","title":"LAS Datasets","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"A LASDataset is a wrapper around data from a LAS file that acts as an interface to read, write and modify your LAS data. In general, a LAS file will have the following contents:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"File Header: contains metadata about the file contents and byte layout\nVLRs: Variable length records of data that appear before the point records\nUser-defined bytes: Additional bytes included after the last VLR and before the first point record\nLAS point records: data assigned to each point in the point cloud (following a specific format specified in the header)\nEVLRs : Extended VLRs that come after the point records (allows larger data payloads)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"These are contained in a LASDataset as follows","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"LASDataset","category":"page"},{"location":"interface/#LASDatasets.LASDataset-interface","page":"Interface","title":"LASDatasets.LASDataset","text":"mutable struct LASDataset\n\nA wrapper around a LAS dataset. Contains point cloud data in tabular format as well as metadata and VLR's/EVLR's\n\nheader::LasHeader\npointcloud::TypedTables.Table\n_user_data::Union{Missing, TypedTables.FlexTable}: Additional user data assigned to each point that aren't standard LAS fields\nvlrs::Vector{LasVariableLengthRecord}\nevlrs::Vector{LasVariableLengthRecord}\nuser_defined_bytes::Vector{UInt8}\nunit_conversion::StaticArraysCore.SVector{3, Float64}\n\n\n\n\n\n","category":"type"},{"location":"interface/","page":"Interface","title":"Interface","text":"You can query the contents of your LASDataset by using the following functions:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"get_header\nget_pointcloud\nget_vlrs\nget_evlrs\nget_user_defined_bytes","category":"page"},{"location":"interface/#LASDatasets.get_header-interface","page":"Interface","title":"LASDatasets.get_header","text":"get_header(las::LASDataset) -> LasHeader\n\n\nExtract the header information from a LASDataset las\n\n\n\n\n\n","category":"function"},{"location":"interface/#LASDatasets.get_pointcloud-interface","page":"Interface","title":"LASDatasets.get_pointcloud","text":"get_pointcloud(las::LASDataset) -> TypedTables.Table\n\n\nExtract point cloud data as a Table from a LASDataset las\n\n\n\n\n\n","category":"function"},{"location":"interface/#LASDatasets.get_vlrs-interface","page":"Interface","title":"LASDatasets.get_vlrs","text":"get_vlrs(las::LASDataset) -> Vector{LasVariableLengthRecord}\n\n\nExtract the set of Variable Length Records from a LASDataset las\n\n\n\n\n\n","category":"function"},{"location":"interface/#LASDatasets.get_evlrs-interface","page":"Interface","title":"LASDatasets.get_evlrs","text":"get_evlrs(\n    las::LASDataset\n) -> Vector{LasVariableLengthRecord}\n\n\nExtract the set of Extended Variable Length Records from a LASDataset las\n\n\n\n\n\n","category":"function"},{"location":"interface/#LASDatasets.get_user_defined_bytes-interface","page":"Interface","title":"LASDatasets.get_user_defined_bytes","text":"get_user_defined_bytes(las::LASDataset) -> Vector{UInt8}\n\n\nExtract the set of user-defined bytes from a LASDataset las\n\n\n\n\n\n","category":"function"},{"location":"interface/#Reading","page":"Interface","title":"Reading","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"To read the entire contents of a LAS or LAZ file, you can use the load_las function. This returns a LASDataset with all the properties listed above. You also have the option of only loading certain point fields.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"# read the full dataset\nlas = load_las(\"example.las\")\n\n# only extract position and classification\nlas = load_las(\"example.las\", [:position, :classification])","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Note that when reading data, the position units for your points are automatically converted to metres provided they are specified correctly in an OGC Coordinate System WKT string. If not, you can still manually specify what units you would like to convert from (note that they must match the unit naming convention given by OGC WKTs), e.g.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"las = load_las(\"example.las\"; convert_x_y_units = \"us-ft\")","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"load_las","category":"page"},{"location":"interface/#LASDatasets.load_las-interface","page":"Interface","title":"LASDatasets.load_las","text":"load_las(file_name::AbstractString; ...) -> LASDataset\nload_las(\n    file_name::AbstractString,\n    fields;\n    kwargs...\n) -> LASDataset\n\n\nLoad a LAS dataset from a source file\n\nArguments\n\nfile_name : Name of the LAS file to extract data from\nfields : Name of the LAS point fields to extract as columns in the output data. If set to nothing, ingest all available columns. Default DEFAULT_LAS_COLUMNS\n\n\n\n\n\n","category":"function"},{"location":"interface/","page":"Interface","title":"Interface","text":"You can also choose to just load the points themselves (in tabular format), header or VLRs rather than the whole datsset by using the following functions:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"load_pointcloud\nload_header\nload_vlrs","category":"page"},{"location":"interface/#LASDatasets.load_pointcloud-interface","page":"Interface","title":"LASDatasets.load_pointcloud","text":"load_pointcloud(\n    file_name::AbstractString;\n    ...\n) -> TypedTables.Table{_A, _B, NamedTuple{names, T}} where {_A<:NamedTuple, _B, names, T<:Tuple{Vararg{AbstractArray{<:Any, _B}}}}\nload_pointcloud(\n    file_name::AbstractString,\n    fields::Union{Nothing, AbstractVector{Symbol}};\n    kwargs...\n) -> TypedTables.Table{_A, _B, NamedTuple{names, T}} where {_A<:NamedTuple, _B, names, T<:Tuple{Vararg{AbstractArray{<:Any, _B}}}}\n\n\nIngest LAS point data in a tabular format\n\n\n\n\n\n","category":"function"},{"location":"interface/#LASDatasets.load_header-interface","page":"Interface","title":"LASDatasets.load_header","text":"load_header(file_name::AbstractString) -> LasHeader\n\n\nIngest a LAS header from a file\n\n\n\n\n\n","category":"function"},{"location":"interface/#LASDatasets.load_vlrs-interface","page":"Interface","title":"LASDatasets.load_vlrs","text":"load_vlrs(\n    file_name::AbstractString,\n    header::LasHeader\n) -> Any\n\n\nIngest a set of variable length records from a LAS file\n\nload_vlrs(file_name, header)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/read.jl:57.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Writing","page":"Interface","title":"Writing","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"You can write the contents of your LASDataset to a file by using the save_las function. Note that this takes either a LASDataset on its own or a tabular point cloud with (E)VLRs and user-defined bytes supplied separately.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"save_las","category":"page"},{"location":"interface/#LASDatasets.save_las-interface","page":"Interface","title":"LASDatasets.save_las","text":"save_las(\n    file_name::AbstractString,\n    pointcloud::AbstractVector{<:NamedTuple};\n    vlrs,\n    evlrs,\n    user_defined_bytes,\n    scale,\n    kwargs...\n)\n\n\nSaves a pointcloud to LAS or LAZ. The appropriate LAS version and point format is inferred from the contents of your point cloud\n\nArguments\n\nfile_name : Name of the LAS file to save the data into\npointcloud : Point cloud data in a tabular format\n\nKeyword Arguments\n\nvlrs : Collection of Variable Length Records to write to the LAS file, default LasVariableLengthRecord[]\nevlrs : Collection of Extended Variable Length Records to write to the LAS file, default LasVariableLengthRecord[]\nuser_defined_bytes : Any user-defined bytes to write in between the VLRs and point records, default UInt8[]\nscale : Scaling factor applied to points on writing, default LASDatasets.POINT_SCALE\n\n\n\nsave_las(\n    file_name,\n    pointcloud;\n    vlrs,\n    evlrs,\n    user_defined_bytes,\n    scale,\n    kwargs...\n)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/write.jl:18.\n\n\n\n\n\n","category":"function"},{"location":"interface/","page":"Interface","title":"Interface","text":"For example, if you have the whole dataset:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"save_las(\"my_las.las\", las)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Alternatively, if you just have the point cloud data as a Table:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"using StaticArrays\nusing TypedTables\n\npc = Table(position = rand(SVector{3, Float64}, 10), classification = rand(UIn8, 10))\nsave_las(\"my_las.las\", pc)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Note that when you supply just the point cloud outside of a LASDataset, LASDatasets.jl will automatically construct the appropriate header for you so you don't need to worry about the specifics of appropriate point formats etc. ","category":"page"},{"location":"interface/#Modifying-LAS-Contents","page":"Interface","title":"Modifying LAS Contents","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"You can modify point fields in your LASDataset by adding new columns or merging in values from an existing vector.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"add_column!\nmerge_column!","category":"page"},{"location":"interface/#LASDatasets.add_column!-interface","page":"Interface","title":"LASDatasets.add_column!","text":"add_column!(\n    las::LASDataset,\n    column::Symbol,\n    values::AbstractArray{T, 1}\n)\n\n\nAdd a column with name column and set of values to a las dataset\n\n\n\n\n\n","category":"function"},{"location":"interface/#LASDatasets.merge_column!-interface","page":"Interface","title":"LASDatasets.merge_column!","text":"merge_column!(\n    las::LASDataset,\n    column::Symbol,\n    values::AbstractVector\n) -> Any\n\n\nMerge a column with name column and a set of values into a las dataset\n\n\n\n\n\n","category":"function"},{"location":"interface/","page":"Interface","title":"Interface","text":"You can also add or remove (E)VLRs using the following functions, and set an existing (E)VLR as superseded if it's an old copy of a record.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"add_vlr!\nremove_vlr!\nset_superseded!","category":"page"},{"location":"interface/#LASDatasets.add_vlr!-interface","page":"Interface","title":"LASDatasets.add_vlr!","text":"add_vlr!(\n    las::LASDataset,\n    vlr::LasVariableLengthRecord\n) -> Any\n\n\nAdd a vlr into the set of VLRs in a LAS dataset las. Note that this will modify the header content of las, including updating its LAS version to v1.4 if vlr is extended\n\n\n\n\n\n","category":"function"},{"location":"interface/#LASDatasets.remove_vlr!-interface","page":"Interface","title":"LASDatasets.remove_vlr!","text":"remove_vlr!(\n    las::LASDataset,\n    vlr::LasVariableLengthRecord\n) -> Union{Nothing, Int64}\n\n\nRemove a vlr from set of VLRs in a LAS dataset las. Note that this will modify the header content of las\n\n\n\n\n\n","category":"function"},{"location":"interface/#LASDatasets.set_superseded!-interface","page":"Interface","title":"LASDatasets.set_superseded!","text":"set_superseded!(vlr::LasVariableLengthRecord) -> UInt16\n\n\nMark a VLR as \"superseded\", meaning it has been replaced by a newer record when modifying the LAS file. Note: The LAS spec only allows for 1 superseded record per LAS file\n\n\n\n\n\nset_superseded!(\n    las::LASDataset,\n    vlr::LasVariableLengthRecord\n) -> UInt16\n\n\nMark a VLR vlr as superseded in a dataset las\n\n\n\n\n\n","category":"function"},{"location":"user_fields/#User-Defined-Point-Fields","page":"User Fields","title":"User-Defined Point Fields","text":"","category":"section"},{"location":"user_fields/","page":"User Fields","title":"User Fields","text":"In a LAS file, the header specifies a data record length, which is the number of bytes used per point record in the file. Note that this number could be larger than the minimal number of bytes needed to store the point format, and if this is the case, the point records will have \"extra bytes\" associated with them. The LAS 1.4 spec introduces an Extra Bytes VLR, which documents extra fields (which we will refer to as \"user fields\") associated to each point record with their name and data type, amongst other information. Note that in legacy versions, you could also store these \"extra bytes\" for point records, but there is no way to infer what type and what field names they have, so they are saved in the record as \"Undocumented Bytes\".","category":"page"},{"location":"user_fields/","page":"User Fields","title":"User Fields","text":"You can save user fields in your point cloud quite easily by including them as columns in your point cloud table. For example, you can save the user field \"thing\" along with your points and their classifications as follows:","category":"page"},{"location":"user_fields/","page":"User Fields","title":"User Fields","text":"pc = Table(position = rand(SVector{3, Float64}, 10), classification = rand(UIn8, 10), thing = rand(10))\nsave_las(\"my_pc.las\", pc)","category":"page"},{"location":"user_fields/","page":"User Fields","title":"User Fields","text":"Under the hood, LASDatasets.jl will automatically create the appropriate header fields for data record lengths etc. and will also create the appropriate Extra Bytes VLRs and save them in your LAS file. ","category":"page"},{"location":"user_fields/","page":"User Fields","title":"User Fields","text":"You can also add user fields to your LAS datasets as you go by calling add_column! with your new data and column name:","category":"page"},{"location":"user_fields/","page":"User Fields","title":"User Fields","text":"add_column!(las, :thing, rand(10))","category":"page"},{"location":"user_fields/","page":"User Fields","title":"User Fields","text":"This will add the user field \"thing\" to your dataset las and append the appropriate Extra Bytes VLRs to it. ","category":"page"},{"location":"user_fields/","page":"User Fields","title":"User Fields","text":"Reading user fields from LAS files is just as easy, since you can simply specify the desired user fields in your requested columns, e.g.","category":"page"},{"location":"user_fields/","page":"User Fields","title":"User Fields","text":"las = load_las(\"my_pc.las\", [:position, :classification, :thing])","category":"page"},{"location":"user_fields/","page":"User Fields","title":"User Fields","text":"Note that user fields can also be vectors of static vectors, and once again LASDatasets.jl will automatically save the appropriate Extra Bytes VLRs for you so you can specify them as you would any other user field:","category":"page"},{"location":"user_fields/","page":"User Fields","title":"User Fields","text":"using StaticArrays\npc = Table(position = rand(SVector{3, Float64}, 10), classification = rand(UIn8, 10), thing = rand(SVector{3, Float64}, 10))\nsave_las(\"my_pc.las\", pc)\nlas = load_las(\"my_pc.las\", [:position, :classification, :thing])","category":"page"},{"location":"user_fields/","page":"User Fields","title":"User Fields","text":"It's also worth mentioning that you can save \"undocumented bytes\" to any point as well by labelling them with the column :undocumented_bytes. In practice, it is possible to have point records with user fields and undocumented bytes, just one or the other, or neither (just the LAS point itself). For more details see here.","category":"page"},{"location":"points/#Points","page":"Points","title":"Points","text":"","category":"section"},{"location":"points/","page":"Points","title":"Points","text":"LAS 1.4 supports 11 point formats which are directly represented by Julia structs. They each implement the abstract type LasPoint{N}, which is parametrised by the point format ID N. Each point format thus has a concrete struct of the form LasPointN <: LasPoint{N} that implements the abstract type for that format ID. ","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"LasPoint0\nLasPoint1\nLasPoint2\nLasPoint3\nLasPoint4\nLasPoint5\nLasPoint6\nLasPoint7\nLasPoint8\nLasPoint9\nLasPoint10","category":"page"},{"location":"points/#LASDatasets.LasPoint0-points","page":"Points","title":"LASDatasets.LasPoint0","text":"ASPRS LAS point data record format 0\n\n\n\n\n\n","category":"type"},{"location":"points/#LASDatasets.LasPoint1-points","page":"Points","title":"LASDatasets.LasPoint1","text":"ASPRS LAS point data record format 1\n\n\n\n\n\n","category":"type"},{"location":"points/#LASDatasets.LasPoint2-points","page":"Points","title":"LASDatasets.LasPoint2","text":"ASPRS LAS point data record format 2\n\n\n\n\n\n","category":"type"},{"location":"points/#LASDatasets.LasPoint3-points","page":"Points","title":"LASDatasets.LasPoint3","text":"ASPRS LAS point data record format 3\n\n\n\n\n\n","category":"type"},{"location":"points/#LASDatasets.LasPoint4-points","page":"Points","title":"LASDatasets.LasPoint4","text":"ASPRS LAS point data record format 4\n\n\n\n\n\n","category":"type"},{"location":"points/#LASDatasets.LasPoint5-points","page":"Points","title":"LASDatasets.LasPoint5","text":"ASPRS LAS point data record format 5\n\n\n\n\n\n","category":"type"},{"location":"points/#LASDatasets.LasPoint6-points","page":"Points","title":"LASDatasets.LasPoint6","text":"ASPRS LAS point data record format 6\n\n\n\n\n\n","category":"type"},{"location":"points/#LASDatasets.LasPoint7-points","page":"Points","title":"LASDatasets.LasPoint7","text":"ASPRS LAS point data record format 7\n\n\n\n\n\n","category":"type"},{"location":"points/#LASDatasets.LasPoint8-points","page":"Points","title":"LASDatasets.LasPoint8","text":"ASPRS LAS point data record format 8\n\n\n\n\n\n","category":"type"},{"location":"points/#LASDatasets.LasPoint9-points","page":"Points","title":"LASDatasets.LasPoint9","text":"ASPRS LAS point data record format 9\n\n\n\n\n\n","category":"type"},{"location":"points/#LASDatasets.LasPoint10-points","page":"Points","title":"LASDatasets.LasPoint10","text":"ASPRS LAS point data record format 10\n\n\n\n\n\n","category":"type"},{"location":"points/","page":"Points","title":"Points","text":"You can get the concrete point format struct and the point format ID for a given LasPoint type with the following helper functions:","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"LASDatasets.get_point_format\nLASDatasets.get_point_format_id","category":"page"},{"location":"points/#LASDatasets.get_point_format-points","page":"Points","title":"LASDatasets.get_point_format","text":"Helper function to get the LAS point format associated with a LAS point record\n\nget_point_format(table)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/parse_points.jl:19.\n\nget_point_format(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/points.jl:230.\n\nget_point_format(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/points.jl:231.\n\nget_point_format(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/points.jl:232.\n\nget_point_format(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/points.jl:233.\n\nget_point_format(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/points.jl:234.\n\nget_point_format(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/points.jl:235.\n\nget_point_format(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/points.jl:236.\n\nget_point_format(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/points.jl:237.\n\nget_point_format(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/points.jl:238.\n\nget_point_format(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/points.jl:239.\n\nget_point_format(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/points.jl:240.\n\nget_point_format(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/points.jl:252.\n\nget_point_format(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/records.jl:124.\n\nget_point_format(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/records.jl:154.\n\nget_point_format(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/records.jl:185.\n\nget_point_format(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/records.jl:212.\n\n\n\n\n\n","category":"function"},{"location":"points/#LASDatasets.get_point_format_id-points","page":"Points","title":"LASDatasets.get_point_format_id","text":"get_point_format_id(_::Type{T<:LasPoint{N}}) -> Any\n\n\nGet the numeric format ID corresponding to a particular point format\n\nget_point_format_id(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/points.jl:249.\n\nget_point_format_id(_)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/points.jl:250.\n\n\n\n\n\n","category":"function"},{"location":"#LASDatasets.jl","page":"Home","title":"LASDatasets.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for reading and writing LAS data. LAS is a public file format for saving and loading 3D point cloud data, and its source repository can be found here. This package currently supports LAS specifications 1.1-1.4 (see here for the 1.4 spec.)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some key features included in this package are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"High-level functions for reading and writing LAS data in tabular formats using TypedTables.jl\nAutomatic detection of LAS point formats from data\nReading and writing Julia-native structs as Variable Length Records (VLRs) and Extended Variable Length Records (EVLRs)\nEasy manipulation of file header properties","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/#Data-Consistency","page":"Internals","title":"Data Consistency","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"When creating a LASDataset or writing a tabular point cloud out to a file, we need to make sure that the header information we provide is consistent with that of the point cloud and any VLRs and user bytes. Internally, this is done using the function make_consistent_header!, which compares a LasHeader and some LAS data and makes sure the header has the appropriate data offsets, flags and other metadata. This will, for example, make sure that the numbers of points, VLRs and EVLRs are consistent with the data we've provided, so your LASDataset is guaranteed to be consistent.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"LASDatasets.make_consistent_header!\nLASDatasets.make_consistent_header","category":"page"},{"location":"internals/#LASDatasets.make_consistent_header!-internals","page":"Internals","title":"LASDatasets.make_consistent_header!","text":"make_consistent_header!(\n    header::LasHeader,\n    pointcloud::AbstractVector{<:NamedTuple},\n    vlrs::Vector{<:LasVariableLengthRecord},\n    evlrs::Vector{<:LasVariableLengthRecord},\n    user_defined_bytes::Vector{UInt8}\n) -> UInt16\n\n\nEnsure that a LAS header is consistent with a given pointcloud data coupled with sets of vlrs, evlrs and user_defined_bytes\n\n\n\n\n\n","category":"function"},{"location":"internals/#LASDatasets.make_consistent_header-internals","page":"Internals","title":"LASDatasets.make_consistent_header","text":"make_consistent_header(\n    pointcloud::AbstractVector{<:NamedTuple},\n    point_format::Type{TPoint<:LasPoint},\n    vlrs::Vector{<:LasVariableLengthRecord},\n    evlrs::Vector{<:LasVariableLengthRecord},\n    user_defined_bytes::Vector{UInt8},\n    scale::Real\n) -> LasHeader\n\n\nConstruct a LAS header that is consistent with a given pointcloud data in a specific LAS point_format, coupled with sets of vlrs, evlrs and user_defined_bytes \n\n\n\n\n\n","category":"function"},{"location":"internals/#Third-Party-Packages","page":"Internals","title":"Third Party Packages","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"This package relies heavily upon PackedReadWrite.jl to speed up the reading and writing of LasPoints and some of our VLRs.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"We also use BufferedStreams.jl to drastically reduce I/O overhead.","category":"page"},{"location":"internals/#Point-Records","page":"Internals","title":"Point Records","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"As outlined in the User Fields Section, in order to offer full support of \"extra point data\" in our LAS files, we treat LAS point records as having a point, extra user fields and a set of undocumented bytes. Internally, however, this is broken up into 4 separate classes each implementing the LasRecord abstract type. These correspond to each combination of a point with/without user fields/undocumented bytes.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"LASDatasets.LasRecord\nLASDatasets.PointRecord\nLASDatasets.ExtendedPointRecord\nLASDatasets.UndocPointRecord\nLASDatasets.FullRecord","category":"page"},{"location":"internals/#LASDatasets.LasRecord-internals","page":"Internals","title":"LASDatasets.LasRecord","text":"abstract type LasRecord\n\nAn abstract form of a LAS record. These are points with some additional information possibly included\n\n\n\n\n\n","category":"type"},{"location":"internals/#LASDatasets.PointRecord-internals","page":"Internals","title":"LASDatasets.PointRecord","text":"struct PointRecord{TPoint} <: LASDatasets.LasRecord\n\nA LAS record that only has a point\n\npoint::Any: The LAS point stored in this record\n\n\n\n\n\n","category":"type"},{"location":"internals/#LASDatasets.ExtendedPointRecord-internals","page":"Internals","title":"LASDatasets.ExtendedPointRecord","text":"struct ExtendedPointRecord{TPoint, Names, Types} <: LASDatasets.LasRecord\n\nA LAS record that has a LAS point and extra user-defined point fields. Note that these must be documented as ExtraBytes VLRs in the LAS file\n\npoint::Any: The LAS point stored in this record\nuser_fields::LASDatasets.UserFields: Extra user fields associated with this point\n\n\n\n\n\n","category":"type"},{"location":"internals/#LASDatasets.UndocPointRecord-internals","page":"Internals","title":"LASDatasets.UndocPointRecord","text":"struct UndocPointRecord{TPoint, N} <: LASDatasets.LasRecord\n\nA LAS record that has a point as well as additional undocumented bytes (i.e. that don't have an associated ExtraBytes VLR)\n\npoint::Any: The LAS point stored in this record\nundoc_bytes::StaticArraysCore.SVector{N, UInt8} where N: Array of extra bytes after the point that haven't been documented in the VLRs\n\n\n\n\n\n","category":"type"},{"location":"internals/#LASDatasets.FullRecord-internals","page":"Internals","title":"LASDatasets.FullRecord","text":"struct FullRecord{TPoint, Names, Types, N} <: LASDatasets.LasRecord\n\nA LAS record that has a LAS point, extra user-defined fields and additional undocumented extra bytes\n\npoint::Any: The LAS point stored in this record\nuser_fields::LASDatasets.UserFields: Extra user fields associated with this point\nundoc_bytes::StaticArraysCore.SVector{N, UInt8} where N: Array of extra bytes after the point that haven't been documented in the VLRs\n\n\n\n\n\n","category":"type"},{"location":"internals/","page":"Internals","title":"Internals","text":"This was done largely to increase performance of reading point records, since having one single type for point records would require more conditional checks to see if certain extra fields need to be read from a file which ends up congesting the read process. Instead, we use Julia's multiple dispatch and define Base.read and Base.write methods for each record type and avoid these checks and also decrease the type inference time when reading these into a vector.","category":"page"},{"location":"internals/#Writing-Optimisations","page":"Internals","title":"Writing Optimisations","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Typically, Julia is slower at performing multiple consecutive smaller writes to an IO channel than one much larger write. For this reason, when writing point records to a LAS file, we first construct a vector of bytes from the records and then write that whole vector to the file. This is possible since for each point record we know:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"How many bytes the point format is,\nHow many user fields in this record and their data size in bytes and\nHow many undocumented bytes there are.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"This is done using LASDatasets.get_record_bytes, which takes a collection of LAS records and writes each LAS field, user field and extra bytes collection into its correct location in the final byte vector.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"In order to do this, we need to frequently access each field in a (potentially huge) list of records, which in normal circumstances is slow. We instead first pass our records into a StructVector using StructArrays.jl which vastly increases the speed at which we can access these fields and broadcast over them.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"LASDatasets.get_record_bytes","category":"page"},{"location":"internals/#LASDatasets.get_record_bytes-internals","page":"Internals","title":"LASDatasets.get_record_bytes","text":"get_record_bytes(\n    records::StructArrays.StructArray{TRecord<:LASDatasets.LasRecord, 1},\n    vlrs::Vector{LasVariableLengthRecord}\n) -> Any\n\n\nConstruct an array of bytes that correctly encodes the information stored in a set of LAS records according to the spec\n\n\n\n\n\n","category":"function"},{"location":"internals/#Automatic-Support-for-User-Fields","page":"Internals","title":"Automatic Support for User Fields","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"In order for the system to automatically handle a user supplying their own custom fields in a point cloud table, we make some checks on field types and have processes in place that ensure each column has an ExtraBytes VLR associated to it.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Firstly, the LAS 1.4 spec officially supports the following data types directly: UInt8, Int8, UInt16, Int16, UInt32, Int32, UInt64, Int64, Float32 and Float64","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"This means that every ExtraBytes VLR must have a data type among these values (note that vectors are not directly supported). LASDatasets.jl supports static vectors (static sizing is essential) as user fields as well by internally separating out vector components and adding an ExtraBytes VLR for each component following the naming convention in the spec. That is, for a user field with N entries, the individual component names that are documented in the VLRs are \"col [0]\", \"col [1]\", ..., \"col [N - 1]\".","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"When a user passes a custom field to the system, it will firstly check that the data type for this field is either one of the above types or an SVector of one. If it is a vector, it will construct a list of the component element field names as above. Then, it will extract all ExtraBytes VLRs and check if any of them have matching names and update them iff they exist so their data type matches the new type supplied. If these are new fields, a new ExtraBytes VLR will be added per field name. Finally, the header is updated to reflect the new number of VLRs, the new data offsets and the new point record lengths.","category":"page"},{"location":"vlrs/#Variable-Length-Records","page":"Variable Length Records","title":"Variable Length Records","text":"","category":"section"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"Variable Length Records are useful packets of data that one can include between the header block and start of the point records in a LAS file. The LAS 1.4 spec also allows for larger data payloads to be stored as Extended Variable Length Records, which are stored at the end of the file after the point records. The difference between these is that regular VLRs can only have a payload up to 2^16 bytes whereas EVLRs can have a payload up to 2^64.","category":"page"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"All types of VLRs (regular and extended) are wrapped inside a LasVariableLengthRecord struct, which holds the data payload as well as the relevant VLR IDs and metadata. Each LasVariableLengthRecord is parametrised by the type of data in its payload which makes LASDatasets.jl able to handle parsing each VLR to/from a native Julia struct automatically.","category":"page"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"LasVariableLengthRecord","category":"page"},{"location":"vlrs/#LASDatasets.LasVariableLengthRecord-vlrs","page":"Variable Length Records","title":"LASDatasets.LasVariableLengthRecord","text":"mutable struct LasVariableLengthRecord{TData}\n\nA variable length record included in a LAS file. This stores a particular data type TData in the record, which can be a known VLR such as a WKT transform or a custom struct. To properly define I/O methods for VLR's of custom structs, you must register which user and record ID's this struct type  will use using \n\n@register_vlr_type(TData, user_id, record_ids)\n\nAnd overload the methods read_vlr_data and write_vlr_data for your type TData\n\nSee the LAS v1.4 spec here for more details.\n\nreserved::UInt16\nuser_id::String\nrecord_id::UInt16: Numerical ID assigned to this record type\ndescription::String\ndata::Any\nextended::Bool\n\n\n\n\n\n","category":"type"},{"location":"vlrs/#Coordinate-Reference-System-VLRs","page":"Variable Length Records","title":"Coordinate Reference System VLRs","text":"","category":"section"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"The LAS 1.4 spec provides definitions for storing coordinate reference system details as VLRs. These are implemented as their own structs so they can be wrapped inside LasVariableLengthRecords. These are split into two flavours: WKT, which uses the OpenGIS coordinate transformation service implementation specification here, and GeoTiff, which are included for legacy support for specs 1.1-1.3 (and are incompatible with LAS point formats 6-10).","category":"page"},{"location":"vlrs/#WKT","page":"Variable Length Records","title":"WKT","text":"","category":"section"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"LASDatasets.jl supports the OGC Coordinate System WKT Record, which is handled by the struct OGC_WKT. Currently we don't support OGC Math Transform WKT, however this could be supported in a future release.","category":"page"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"OGC_WKT","category":"page"},{"location":"vlrs/#LASDatasets.OGC_WKT-vlrs","page":"Variable Length Records","title":"LASDatasets.OGC_WKT","text":"struct OGC_WKT\n\nA Coordinate System WKT record specified by the Open Geospatial Consortium (OGC) spec\n\nwkt_str::String: The WKT formatted string for the coordinate system\nnb::Int64: Number of bytes in the WKT string\nunit::Union{Missing, String}: Units applied along the horizontal (XY) plane in this coordinate system\nvert_unit::Union{Missing, String}: Units applied along the vertical (Z) axis in this coordinate system. Note: this will not in general match the horizontal coordinate\n\n\n\n\n\n","category":"type"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"One benefit of using the OGC WKT is that you can specify what units of measurement are used for your point coordinates both in the XY plane and along the Z axis. When reading a LAS file, the system can detect if an OGC WKT is present and will, if requested by the user, convert the point coordinates to metres.","category":"page"},{"location":"vlrs/#GeoTiff","page":"Variable Length Records","title":"GeoTiff","text":"","category":"section"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"GeoTiff VLRs are supported for legacy versions and also have their own Julia struct, which are given below. ","category":"page"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"GeoKeys\nGeoDoubleParamsTag\nGeoAsciiParamsTag","category":"page"},{"location":"vlrs/#LASDatasets.GeoKeys-vlrs","page":"Variable Length Records","title":"LASDatasets.GeoKeys","text":"struct GeoKeys\n\nContains the TIFF keys that defines a coordinate system. A complete description can be found in the GeoTIFF format specification. \n\nAs per the spec:\n\nkey_directory_version = 1 always\nkey_revision = 1 always\nminor_revision = 0 always\n\nThis may change in future LAS spec versions\n\n\n\n\n\n","category":"type"},{"location":"vlrs/#LASDatasets.GeoDoubleParamsTag-vlrs","page":"Variable Length Records","title":"LASDatasets.GeoDoubleParamsTag","text":"struct GeoDoubleParamsTag\n\nA collection of values double_params that are referenced by tag sets in a GeoKeys record\n\n\n\n\n\n","category":"type"},{"location":"vlrs/#LASDatasets.GeoAsciiParamsTag-vlrs","page":"Variable Length Records","title":"LASDatasets.GeoAsciiParamsTag","text":"struct GeoAsciiParamsTag\n\nAn array of ASCII data that contains many strings separated by null terminator characters in ascii_params. These are referenced by position from the data in a GeoKeys record\n\n\n\n\n\n","category":"type"},{"location":"vlrs/#Other-Specification-Defined-VLRs","page":"Variable Length Records","title":"Other Specification-Defined VLRs","text":"","category":"section"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"The LAS 1.4 spec also includes several other recognised VLRs that are automatically supported in LASDatasets.jl. ","category":"page"},{"location":"vlrs/#Classification-Lookup","page":"Variable Length Records","title":"Classification Lookup","text":"","category":"section"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"LAS 1.4 allows you to specify classification labels 0-255 for your point formats 6-10, where labels 0-22 having specific classes associated with them, classes 23-63 being reserved and classes 64-255 being user-definable. To give context to what your classes mean, you can add a Classification Lookup VLR into your LAS file, which is just a collection of classification labels paired with a string description. In LASDatasets.jl, this is handled as a ClassificationLookup:","category":"page"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"ClassificationLookup","category":"page"},{"location":"vlrs/#LASDatasets.ClassificationLookup-vlrs","page":"Variable Length Records","title":"LASDatasets.ClassificationLookup","text":"struct ClassificationLookup\n\nA lookup record for classification labels. Each class has a short description telling you what it is.\n\nclass_description_map::Dict{UInt8, String}: Mapping of each class to a description\n\n\n\nClassificationLookup(class_description_map)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/registered_vlrs.jl:14.\n\nClassificationLookup(class_descriptions)\n\ndefined at /home/runner/work/LASDatasets.jl/LASDatasets.jl/src/registered_vlrs.jl:22.\n\n\n\n\n\n","category":"type"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"As an example, you can add a Classification Lookup VLR to your LAS file as follows:","category":"page"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"pc = Table(position = rand(SVector{3, Float64}, 100), classification = rand((65, 100), 100))\n# class 65 represents mailboxes, 100 represents street signs\nlookup = ClassificationLookup(65 => \"Mailboxes\", 100 => \"Street signs\")\n# make sure you set the right VLR IDs\nvlrs = [LasVariableLengthRecord(\"LASF_Spec\", 0, \"Classification Lookup\", lookup)]\nsave_las(\"pc.las\", pc; vlrs = vlrs)","category":"page"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"You can then read the LAS data and extract the classification lookup:","category":"page"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"las = load_las(\"pc.las\")\n# look for the classification lookup VLR by checking for its user and record IDs\nlookup_vlr = extract_vlr_type(get_vlrs(las), \"LASF_Spec\", 0)\nlookup = get_data(lookup_vlr[1])","category":"page"},{"location":"vlrs/#Text-Area-Descriptions","page":"Variable Length Records","title":"Text Area Descriptions","text":"","category":"section"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"You can add a description for your dataset using a TextAreaDescription data type","category":"page"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"TextAreaDescription","category":"page"},{"location":"vlrs/#LASDatasets.TextAreaDescription-vlrs","page":"Variable Length Records","title":"LASDatasets.TextAreaDescription","text":"struct TextAreaDescription\n\nA wrapper around a text area description, which is used for providing a textual description of the content of the LAS file\n\ntxt::String: Text describing the content of the LAS file\n\n\n\n\n\n","category":"type"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"Using the dataset las above, we can add a description as follows (and save/read it as we did above). Note you can also repeat the way the Classification Lookup was saved above too.","category":"page"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"description = TextAreaDescription(\"This is an example LAS file and has no specific meaning\")\nadd_vlr!(las, LasVariableLengthRecord(\"LASF_Spec\", 3, \"Text Area Description\", description))","category":"page"},{"location":"vlrs/#Extra-Bytes","page":"Variable Length Records","title":"Extra Bytes","text":"","category":"section"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"Extra Bytes VLRs are a type of VLR that documents any user fields that have been added to point records in your LAS data. You can find an in-depth explanation of how to save/load user defined fields to your points here. ","category":"page"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"The Extra Bytes VLRs are represented by the ExtraBytes struct, and have a few methods to get some information from them. Note that currrently LASDatasets.jl only supports automatically detecting and writing the user field name, data type and description to the VLR based on input point data. Support for other fields such as the min/max range, scale/offset factors, etc. may become available in future releases. You can, however, still manually specify these if you choose.","category":"page"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"ExtraBytes\nLASDatasets.name\nLASDatasets.data_type","category":"page"},{"location":"vlrs/#LASDatasets.ExtraBytes-vlrs","page":"Variable Length Records","title":"LASDatasets.ExtraBytes","text":"struct ExtraBytes{TData}\n\nExtra Bytes record that documents an extra field present for a point in a LAS file\n\noptions::UInt8: Specifies whether the min/max range, scale factor and offset for this field is set/meaningful and whether there is a special value to be interpreted as \"NO_DATA\"\nname::String: Name of the extra field\nno_data::Any: A value that's used if the \"NO_DATA\" flag is set in options. Use this if the point doesn't have data for this type\nmin_val::Any: Minimum value for this field, zero if not using\nmax_val::Any: Maximum value for this field, zero if not using\nscale::Any: Scale factor applied to this field, zero if not using\noffset::Any: Offset applied to this field, zero if not using\ndescription::String: Description of this extra field\n\n\n\n\n\n","category":"type"},{"location":"vlrs/#LASDatasets.name-vlrs","page":"Variable Length Records","title":"LASDatasets.name","text":"name(e::ExtraBytes) -> String\n\n\nGet the name of an additional user field that's documented by an extra bytes record e\n\n\n\n\n\n","category":"function"},{"location":"vlrs/#LASDatasets.data_type-vlrs","page":"Variable Length Records","title":"LASDatasets.data_type","text":"data_type(_::ExtraBytes{TData}) -> Any\n\n\nGet the data type of an ExtraBytes record\n\n\n\n\n\n","category":"function"},{"location":"vlrs/#Waveform-Data","page":"Variable Length Records","title":"Waveform Data","text":"","category":"section"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"Currently LASDatasets.jl doesn't have fully extensive support for waveform data and flags, but this will likely be included in future releases. We do, however, support writing waveform packet descriptions as VLRs with the WaveformPacketDescriptor. ","category":"page"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"WaveformPacketDescriptor","category":"page"},{"location":"vlrs/#LASDatasets.WaveformPacketDescriptor-vlrs","page":"Variable Length Records","title":"LASDatasets.WaveformPacketDescriptor","text":"struct WaveformPacketDescriptor\n\nA Wave Packet Descriptor which contains information that describes the configuration of the waveform packets. Since systems may be configured differently at different times throughout a job, the LAS file supports 255 Waveform Packet Descriptors\n\nbits_per_sample::UInt8: Number of bits per sample. 2 to 32 bits per sample are supported\ncompression_type::UInt8: Indicates the compression algorithm used for the waveform packets associated with this descriptor. A value of 0 indicates no compression. Zero is the only value currently supported\nnum_samples::UInt32: Number of samples associated to this packet type. This always corresponds to the decompressed waveform packet\ntemporal_sample_spacing::UInt32: The temporal sample spacing in picoseconds. Example values might be 500, 1000, 2000, and so on, representing digitizer frequencies of 2 GHz, 1 GHz, and 500 MHz respectively.\ndigitizer_gain::Float64: The digitizer gain used to convert the raw digitized value to an absolute digitizer voltage using the formula: 𝑉𝑂𝐿𝑇𝑆 = 𝑂𝐹𝐹𝑆𝐸𝑇 + 𝐺𝐴𝐼𝑁 * 𝑅𝑎𝑤𝑊𝑎𝑣𝑒𝑓𝑜𝑟𝑚𝐴𝑚𝑝𝑙𝑖𝑡𝑢𝑑𝑒\n\ndigitizer_offset::Float64: The digitizer offset used to convert the raw digitized value to an absolute digitizer using formula above\n\n\n\n\n\n","category":"type"},{"location":"vlrs/#Custom-VLRs","page":"Variable Length Records","title":"Custom VLRs","text":"","category":"section"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"As well as the VLR record types mentioned above, you can write your own Julia-native structs as VLRs quite easily using LASDatasets.jl. By default, LASDatasets.jl will just read the raw bytes for your VLRs, so there are a couple of steps to enable correct VLR parsing.","category":"page"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"Firstly, you need to define methods to read and write your data type. For writing, this just means overloading Base.write for your type.","category":"page"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"Reading works a little differently. Since each VLR has a \"record length after header\", the system knows how many bytes each record needs. If your data type has statically-sized fields (like numbers or static arrays), you already know how many bytes you're reading (and this needs to be reflected in a Base.sizeof method for your type). You'll need to overload the function LASDatasets.read_vlr_data for your data type, which accepts the number of bytes to read alongside your type. This allows you to read non-static types for fields as well as static ones.","category":"page"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"read_vlr_data","category":"page"},{"location":"vlrs/#LASDatasets.read_vlr_data-vlrs","page":"Variable Length Records","title":"LASDatasets.read_vlr_data","text":"read_vlr_data(\n    io::IO,\n    _::Type{TData},\n    nb::Integer\n) -> OGC_WKT\n\n\nRead data of type TData that belongs to a VLR by readig nb bytes from an io.  By default this will call Base.read, but for more specific read methods this will need to be overloaded for your type\n\n\n\n\n\n","category":"function"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"As an example, you could have","category":"page"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"struct MyType\n    name::String\n\n    value::Float64\nend\n\n# important to know how many bytes your record will take up\nBase.sizeof(x::MyType) = Base.sizeof(x.name) + 8\n\nfunction LASDatasets.read_vlr_data(io::IO, ::Type{MyType}, nb::Integer)\n    @assert nb ≥ 8 \"Not enough bytes to read data of type MyType!\"\n    # the name will depend on how many bytes we've been told to read\n    name = LASDatasets.readstring(io, nb - 8)\n    value = read(io, Float64)\n    return MyType(name, value)\nend\n\nfunction Base.write(io::IO, x::MyType)\n    write(io, x.name)\n    write(io, x.value)\nend","category":"page"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"Finally, the system needs some way to know what data type to read for the VLR for a specific user ID and record ID, otherwise it will just read the raw bytes back to you. To register the \"official\" IDs to use, you can use the macro @register_vlr_type:","category":"page"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"@register_vlr_type","category":"page"},{"location":"vlrs/#LASDatasets.@register_vlr_type-vlrs","page":"Variable Length Records","title":"LASDatasets.@register_vlr_type","text":"Register a new VLR data type type by associating it with an official user_id and set of record_ids \n\n\n\n\n\n","category":"macro"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"So in our example, we can tell the system that records containing data of type MyType will always have a user ID \"My Custom Records\" and record IDs 1-100:","category":"page"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"@register_vlr_type MyType \"My Custom Records\" collect(1:100)","category":"page"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"And now we can save our MyType VLRs into a LAS file in the same way as we did above for the register VLR types. Note that you can use the function extract_vlr_type on your collection of VLRs to pull out any VLRs with a specific user ID and record ID.","category":"page"},{"location":"vlrs/","page":"Variable Length Records","title":"Variable Length Records","text":"extract_vlr_type","category":"page"},{"location":"vlrs/#LASDatasets.extract_vlr_type-vlrs","page":"Variable Length Records","title":"LASDatasets.extract_vlr_type","text":"extract_vlr_type(\n    vlrs::Vector{<:LasVariableLengthRecord},\n    user_id::String,\n    record_id::Integer\n) -> Any\n\n\nExtract all VLRs with a user_id and record_id from a collection of VLRs, vlrs\n\n\n\n\n\n","category":"function"}]
}
